깃허브
https://github.com/studylabdoc/text/blob/main/20240722.txt

구글드라이브
https://drive.google.com/drive/folders/1MIP3LQNU3oISKebgHWvUCgEVF4_2Xg95?usp=sharing

miro
https://miro.com/app/board/uXjVKwkVIgM=/?share_link_id=305482122361

google docs
https://docs.google.com/document/d/1vbzX5a2MGcT2SaKxQ3SR5XfKiK7ITvymUA98Fyz7eUI/edit?usp=sharing

[랩 접속 방법]
메일 : 20240722
rol.redhat.com  < RHLS 

MY VIRTUAL TRAINING CLASSES
RH134 - Red Hat System Administration II
Class Starts: 월, 7월 22 2024, 10:00 오전 

Class Ends: 금, 7월 26 2024, 06:00 오후 
JOIN

리소스 -> pdf download
랩 > workstation
Web Applications>  Classroom Web Terminal > access

PDF는 MS 엣지로 오픈
10:00 - 18:00 
쉬는시간 : 10 / 15분 
점심시간 : 12:30 - 14:00

[10] < 10page 

[7]
목차

RH134 과정을 위한 사전 명령어
# ls
디렉토리의 컨켄츠 확인
# chmod
권한 변경
# pwd
현재 디렉토리 확인
# passwd
비밀번호 변경
# useradd
계정 생성
# rm
삭제
# cp
복사
# mv
파일 이동 / 이름 변경
# date
시간 확인 / 시간변경 > timedatectl
# touch
파일의 시간 변경 , 빈 파일 생성
# mkdir
디렉토리 생성
# rmdir
빈 디렉토리 삭제 -> rm -rf dir
# id
현재 계정의 정보 확인
UID / GID / groups / selinux data
# cat
파일 확인 / 파일 병합 > 표준 출력 
# tac
파일 출력 방향을 반대로 돌림
# ps
프로세스 확인 / ps / ps -ef / ps aux
# bash
사용자 쉘 명령 / 서브 쉘을 실행 최근에는 bash도 사용하지만 fish / zsh 도 많이 사용중
# su -
접속 된 계정이 아닌 새로운 계정으로 전환 / 최근에는 sudo 명령 권장
# echo
빈 한 줄을 리턴 / 환경변수 호출
# more
cat의 경우에는 라인이 길어도 모두 한번에 출력
페이지 단위로 한 페이지 씩 끊어서 화면에 출력
more와 man에서 사용되는 기능키
* spacebar : 매뉴얼 페이지에서 한 화면 단위로 넘어 갈 때 사용
Enter : 매뉴얼 페이지에서 한 라인씩 넘어 갈 때 사용
b : Back Screen, 한 화면 전 화면으로 넘어갈 때 사용
* /pattern : 특정한 패턴을 빨리 찾을 때 사용
* n : Next, 특정한 패턴을 찾은 후 다음 번째 똑같은 문자열을 찾을 때 사용
h : help 매뉴얼 페이지 안에서 사용 할 수 있는 명령어 소개
* q : quit, 빠져나옴
# man
도움말 
https://linux.die.net/man/
# clear
화면을 청소 / 청소 이후 위의 출력 결과를 알수가 없음
# ln
출력 결과의 앞에 번호를 붙임
# tree
파일시스템의 파일, 디렉토리의 구조화
# dnf
yum, dnf 패키지 관리 프로그램
# chown
소유자 변경 
# umask
기본 권한 변경, 확인
# which
명령어 절대경로 확인
# whereis
매뉴얼 확인
# alias
기본 명령이 아닌 쉽게 사용할 수 있는 약어 생성, 확인
# histroy
사용한 명령어를 확인
# stat
전체 시간 정보 + 권한등 여러가지를 확인
# file
파일의 형식 확인
# cat file1 file2 > file3
표준 출력의 리다이렉션
# find . -name core 2> /dev/null
표준 에러의 리다이렉션
# cat < file1
표준 입력의 리다이렉션
# ssh
원격 접속을 위한 보안 쉘
# scp
원격 파일 복사를 위한 보안 쉘 [사용을 현재 중지]
# sftp
보안 파일 전송 프로토콜
# script
화면에 출력되는 모든 텍스트를 캡처, 저장
# vi
텍스트 에디터
# systemctl
systemd를 위한 명령어
# exit
쉘을 빠져나가기
# export
환경 변수 지정
# ^c
현재 작업중인 내용을 인터럽트하고 강제 종료
# ^d
EOF / EXIT
EOF: 파일의 끝
EXIT: 쉘을 끝내는 단축키
# poweroff
시스템 종료
# reboot
재부팅
# shutdown
시스템 종료 / 유예시간을 부여 할 수 있다. 
# ping
ICMP 프로토콜을 이용하여 헬스 체크 / 조건문에서 사용하기 위해 작성
# ifconfig
NIC 정보 확인 > 최근에는 잘 사용되지 않음.
net-tools 패키지가 있어야 하지만 설치자체를 하지 않음.
ip a 명령으로 대체
# head
파일의 상단 10줄
# tail
파일의 하단 10줄
# who
현재 접속자 확인
# last
사용자들의 접속 기록
# lastb
사용자의 잘못된 접속 기록
# w
현재 접속자의 사용 명령 확인
# while true do ; action ; done
반복문
# df
디스크의 남은 용량 / 파일 시스템 확인
# du
디스크의 사용 용량
# sort
데이터 정렬
# uniq 
데이터의 값 중 유일한 것 하나만 추출
# tee
출력을 두 방향으로 복제
# screen
지금은 tmux 명령으로 변경
쉘을 이용하면 쉘이 꺼지게 되면 작업 중지
내부에서 백 그라운드 작업으로 돌기 때문에 쉘이 꺼져도 계속 작업이 가능.
# mail
s-nail 명령으로 변환
# wall 
현재 실행중인 모든 터미널에 동일한 내용으로 브로드캐스트 
# grep
컨텐츠 내에서 특정 패턴을 찾기 위해 사용
+ 특정 패턴을 걸고 디렉토리나 파일에서 해당 내용이 존재하는 파일을 찾는 용도
# find
inode 정보를 필터링 하여 원하는 파일 / 디렉토리를 찾는 용도
+ 검색된 파일과 디렉토리에 실행 명령을 내려 2차 작업이 가능 

124 / 134 / 199 -> RHCSA

시험을 대비하는 분들을 위해:
1장
연습가이드: 간단한 Bash 스크립트 작성
2장
연습가이드: 반복 실행 사용자 작업 예약
3장
연습가이드: 정확한 시간 유지 관리
4장
연습 가이드: 압축된 tar 아카이브 관리 
tar + gz , bzip2, xz 
5장
연습가이드: 튜닝 프로파일 조정
6장
연습 가이드: SELinux 문제 조사 및 해결
+ 11장 연습 가이드: SELinux 포트 레이블 지정 제어
+ 연습 가이드: 서버 방화벽 관리

7장 8장 all
block storage를 마운트 하고 fstab까지 구성이 가능한 상태 >
LVM 구성 
+ LVM 생성
+ LVM 확장
+ swap

9장
연습 가이드: 네트워크 연결 스토리지 자동 마운트

10장
연습 가이드: 루트 암호 재설정

13장
container build 
container image control
연습 가이드: 컨테이너를 시스템 서비스로 관리

[14]
강의실 환경에 대한 오리엔테이션
workstation : 작업을 위한 컴퓨터
servera,serverb : 실제 작업을 위한 서버 
나머지 서버들은 lab 환경을 위해 존재한다.

시스템의 계정들은 다음과 같다.
student / student
root / redhat

1장
[20]
스크립트 = 자동화
쉘 스크립트, perl, -> [ansible:RHCE:RH294]

스크립트 top-down 
리눅스에 존재하는 왠만한 파일들은 위에서 아래로 읽어 내려감
1 shell을 사용한다는 것을 명시
2 명령어 작성

# vi run.sh
리눅스에서는 파일명 끝의 확장자는 아무 의미 없음.

명령 인터프리터 지정
# < 주석 처리로 진행이 되지만 첫줄에서 #! -> 이 뒤에 오는 파일 명을 가지고 쉘을 실행
sample
#!/usr/bin/bash == #!/bin/bash

실제 사용할 명령 리스트 순서대로 진행

date
echo 'run.sh file'
sleep 2
echo 'run.sh exit'


$ vi run.sh
---------------------------
#!/usr/bin/bash
date
echo 'run.sh file'
sleep 2
echo 'run.sh exit'
---------------------------

i : 입력모드
입력
esc -> 명령행모드
:wq  -> 저장+ 빠져나가기

현재 쉘에서 실행하기
./run.sh
./ = 현재 디렉토리 
run.sh = 실제 사용할 파일
./= /home/student/
./run.sh = /home/student/run.sh
실행을 위해서는 x권한이 필요
[student@workstation ~]$ ls -l run.sh
-rw-r--r--. 1 student student 67 Jul 21 23:12 run.sh
[student@workstation ~]$ chmod u+x run.sh
[student@workstation ~]$ ls -l run.sh
-rwxr--r--. 1 student student 67 Jul 21 23:12 run.sh

명령어를 호출하는 순서
1 hash에서 검색 
  # hash , # hash -r 
2 alias 에서 확인
3 실제 경로를 확인
4 명령어 실행

# command ls
alias 무시후 실제 경로에서만 실행

[student@workstation ~]$ echo $PATH
/home/student/.local/bin:/home/student/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/home/student/.venv/labs/bin
PATH 환경변수는 명령어를 입력 했을때 3번[실제 경로를 확인] 작업을 위한 디렉토리를 모아둔 곳

실제 경로를 확인
[student@workstation ~]$ ls
Desktop    Downloads  Music     Public  Templates
Documents  file1      Pictures  run.sh  Videos
[student@workstation ~]$ mkdir bin
[student@workstation ~]$ mv run.sh bin
[student@workstation ~]$ tree bin
bin
└── run.sh

0 directories, 1 file
run.sh 파일을 bin 디렉토리 아래에 복사.
해당 디렉토리는 /home/student/bin에 존재

0 directories, 1 file
run.sh 파일을 bin 디렉토리 아래에 복사.
해당 디렉토리는 /home/student/bin에 존재

인용 특수 문자 -> 메타캐릭터
shell에서 특수문자를 파일명에 추가 하지 마라.
!@#$%^&*()_ | ‘ “ ; : , . / \ ~ `  -> 쉘에서 하는 기능들이 있다.
명령어 입력 -> 
# ls -l $(which ls)
> 토큰 단위로 분할 [빈칸 ]
1  ls
2  -l
3  $(which ls)
쉘에서는 특수문자를 기능으로 사용을 한다.
파일을 생성 할때:
255 자.
빈칸 쓰지말고
특수문자 쓰지말고
영문자, 대문자, 숫자, -, _ , . 만 가지고 생성
자주 사용되는 메타캐릭터:
# : 주석 처리
\:
1 바로 뒤에 오는 한가지 문자를 해석하지 않음
[student@workstation ~]$ echo \$HOME
$HOME
2 명령어 라인의 끝에 \를 붙이게 되면 PS2 변수를 반환 하면서 라인을 끝내지 않고 아래줄에서 이어서 작성
‘ : ‘text’따옴표 안의 문자열을 해석하지 않음
“: “text”따옴표 안의 문자열을 해석하지 않음 [하지만 해석하는 문자도 있다. \ ` $]
` : `CMD` 역따옴표 안의 명령어를 해석하여 명령어의 결과로 보여준다.
[student@workstation ~]$ echo `date`
Mon Jul 22 01:16:14 AM EDT 2024

[student@workstation ~]$ echo "=====`date`======"
=====Mon Jul 22 01:16:43 AM EDT 2024======
최근에는 `가 아니라 $(CMD)
[student@workstation ~]$ echo $(date)
Mon Jul 22 01:17:29 AM EDT 2024
[student@workstation ~]$ echo "=====$(date)======"
=====Mon Jul 22 01:17:39 AM EDT 2024======

둘의 차이:
`cmd` : 단순하게 명령어를 실행하는 용도
$(cmd) : 임시 환경 변수를 만들어서 작업해야 하는 경우에 많이 사용. 

[student@workstation ~]$  var=$(hostname -s); echo $var 
workstation

쉘에서 임시 변수 지정
text=value
var=$(hostname -s)
; : 명령어의 격리
[student@workstation ~]$ echo ls
ls
[student@workstation ~]$ echo ; ls 

bin      Documents  file1  Pictures  Templates
Desktop  Downloads  Music  Public    Videos
;은 단순한 명령어에서 사용 하시기 바랍니다. 
그러면 단순하지 않은 명령은? = 민감한 명령 삭제. 이동. ..

[root@servera ~]# mkdir /test1
[root@servera ~]# mkdir /test2
[root@servera ~]# touch /test1/file1
[root@servera ~]# mkdir /test
[root@servera ~]# cd /test
[root@servera test]# pwd
/test

/test 라는 곳에서 /test1 아래 있는 모든 파일을 삭제
[root@servera test]# cd /test1 ; rm -rf *   << 요렇게 작업하려고 생각을 함
[root@servera test]# pwd
/test
[root@servera test]# touch file1
[root@servera test]# ls
file1
현재 디렉토리에 파일을 생성
[root@servera test]# cd /testq ; rm -rf *
-bash: cd: /testq: No such file or directory
[root@servera test]# ls
[root@servera test]# 
/test 밑의 파일이 삭제가 되었다.
위험: 이런 경우에는 ; 을 사용하면 안됨
그렇다면 무엇을 사용해야 할까?
[root@servera test]# touch file1
[root@servera test]# pwd
/test
[root@servera test]# ls
file1
&& : 앞의 명령어가 성공의 값일때만 뒤의 명령어를 실행
명령어의 리턴값이 0인 경우에만 뒤의 명령어를 실행
성공의 값 : 
[root@servera test]# ls
file1
[root@servera test]# echo $?
0
0 = 성공 정상
1-255 = 실패 에러

[root@servera test]# cd /testq &&  rm -rf *
-bash: cd: /testq: No such file or directory
[root@servera test]# ls
file1

|| : 명령어의 리턴값이 0이 아닌경우에만 뒤의 명령어를 실행
[root@servera test1]# cd /testq ||  echo 'two command'-bash: cd: /testq: No such file or directory
two command

둘을 합쳐보면 다음과 같이 이용
# CMD && CMD1 || CMD2

쉘 스크립트에서 출력 제공
[user@host ~]$ cat ~/bin/hello 

#!/usr/bin/bash   < 지시어
echo "Hello, world" < echo 명령을 통해 Hello, world를 실행, 출력

 [user@host ~]$ hello 
Hello, world 

[user@host ~]$ cat ~/bin/hello
#!/usr/bin/bash 
echo "Hello, world" 
echo "ERROR: Houston, we have a problem." >&2 

표준 입력 : STDIN: 따로 지정되지 않는 이상 키보드로 입력
표준 출력 : STDOUT: 따로 지정되지 않는 이상 모니터[터미널]로 출력
표준 에러 : STDERR: 따로 지정되지 않는 이상 모니터[터미널]로 출력

리다이렉션 : 파일이나 장치를 통해서 입력, 출력을 할 수 있다.
입력 리다이렉션: cat < file1 
[root@servera test]# echo 'RHEL9 rh134'
[root@servera test]# cat < file1
RHEL9 rh134
< : 표준 입력을 대신하여 파일에서 입력을 받는 용도
출력 리다이렉션: 
[root@servera test]# echo 'RHEL9 rh134'
RHEL9 rh134
[root@servera test]# echo 'RHEL9 rh134' > file1
[root@servera test]# cat file1
RHEL9 rh134
[root@servera test]# echo 'RHEL9 rh134' >> file1 
[root@servera test]# cat file1
RHEL9 rh134
RHEL9 rh134
[root@servera test]# echo 'RHCSA' > file1 
[root@servera test]# cat file1
RHCSA
> : 덮어쓰기, 표준 출력 리다이렉션
>> : 이어쓰기 

에러 리다이렉션:
리눅스는 에러와 출력을 따로 구분한다.
[root@servera test]# echo 111 > /dev/null 
[root@servera test]# cd /testq > /dev/null 
-bash: cd: /testq: No such file or directory

[root@servera test]# cd /testq 2> /dev/null 
[user@host ~]$ cat ~/bin/hello
#!/usr/bin/bash 
echo "Hello, world" 
echo "ERROR: Houston, we have a problem." >&2
 >&2 : 강제로 출력을 표준 에러로 변경

# CMD > file1 2>&1 :  표준 출력과 표준 에러를 file1 하나에 모두 담을때 

[24]
연습 가이드 사용법

연습 가이드 자체는 같이 하지는 않습니다.
시험 관련된 가이드 

[27]
스크립트에서 사용되는 반복문 / 조건문
반복문
for
while 
조건문
if

전체 시스템에서 부팅이 다 되었는가?
계정을 1-1000번까지 생성
openssl - 암호화 된 암호  생성 
useradd – password 
chage -d 0 


for문
for VARIABLE in LIST; do 
COMMAND VARIABLE
 done

for [변수] in [반복할 문자| 파일| 명령어로 숫자를 반복]; do 
실제 실행할 명령어 
sleep 1 < 반복문 이지만 한번씩 끊어서 작업 하기 위해 sleep으로 한 타임씩 끊어주기
done

변수:
보통 단일 문자로 많이 사용  특정한 문자열로 작성하는 것이 이후에 에러를 줄일수 있다.
[반복할 문자| 파일| 명령어로 숫자를 반복]
반복할 문자: 1 2 3 4 , a b c  d  반복문에서 사용할 문자를 수동으로 작성
파일 : `cat list`
명령어로 숫자를 반복: 
seq 1 100 
seq -w 1 100
001부터 시작




[root@servera ~]# for NUMBER in 1 2 3 4 ; do 
 > echo "hostname: lab.server${NUMBER}.example.com"
> done

변수로는 NUMBER 문자열 사용
반복된 숫자는 1- 4까지 사용
${NUMBER} 변수 지정시 중괄호 이용

반복문이 아닌 글로빙 기능을 사용하기
# touch file{1..10}
file1번에서 file10번까지 생성
bash shell 4.0 이상에서 제공 되는 기능

Bash 스크립트 종료 코드
쉘을 종료 할 때 에러 코드를 강제 삽입
스크립트가 하나로 이루어진게 아니라 이후 조건문을 위해 두개 이상의 스크립트가 결합되는 경우

https://blog.naver.com/mmarine/70094622832 


if?
조건식
if [조건] ; then
 조건이 맞는 경우의 실행
fi

if [조건] ; then
 조건이 맞는 경우의 실행
else 
 조건이 맞지않는 경우의 실행
fi

기본적으로 사용하면 좋은 for if 
while : 참인 경우 무한 반복

[root@servera test]# while true
> do
> echo "===========$(date)=========="
> sleep 1
> done

[root@servera test]# while true; do echo "===========$(date)=========="; sleep 1; done

1 while 
2 for
3 if

지금은 ansible 을 이용하게 되면 위의 조건식들을 더 쉽게 이용 할 수 있음

[35]

현재 레드햇 시험은 크게 두가지 형식으로 가능
오프라인 [특이한 경우에만 오픈] X
1 학동역 에티버스 , 패스트레인  : 키오스크 장비로 시험을 보는 방법
모든 장비가 갖춰져 있음. 몸만 가시면 바로 시험 진행 가능
2 remote exam : 온라인으로 시험을 진행
https://youtu.be/LX3VMIAuPzg?si=EB8FLuRGfzESX7gO
시험에 관련된 사항을 직접 준비.
RHEL DVD 라이브 부팅
네트워크
접속..
조용한 방 +컴퓨터
카메라  2개 
마이크 1개

시험 이후에 보통 30분 안에 결과가 날아옵니다.
PASS / NOPASS
210/300














[root@servera test]# cat list 
cat
dog
concatenate
dogma
category
educated
boondoggle
vindication
chilidog
위와 같은 파일을 생성

[root@servera test]# cat list  | grep cat 
cat
concatenate
category
educated
vindication
cat의 문자열 패턴을 검색

grep 명령이 각 라인별로 검사
문자열의 시작부분 그리고 끝 부분을 대상으로 검색 할 수 있음.

문자열의 시작 부분
[root@servera test]# cat list  | grep ^cat 
cat
category

문자열의 끝부분
[root@servera test]# cat list  | grep cat$
cat

[root@servera test]# cat /etc/ssh/sshd_config | grep port
# If you want to change the port on a SELinux system, you have to tell
# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER
# WARNING: 'UsePAM no' is not supported in Fedora and may cause several
[root@servera test]# cat /etc/ssh/sshd_config | grep -i port
# If you want to change the port on a SELinux system, you have to tell
# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER
#Port 22
# WARNING: 'UsePAM no' is not supported in Fedora and may cause several
#GatewayPorts no

grep를 이용하여 다음과 같이 나옴
/etc/passwd 파일에서 root 라는 단어가 들어있는 라인을 찾아 /root/lines.txt 파일로 생성
1.  순서대로 작성 할것
2. 빈칸이 없을것
3. 파일이 변화되면 안됨

grep을 이용한 특수문자 찾기
/etc 밑에서 다음 파일을 확인해 봅시다.
/etc/passwd
/etc/group
/etc/shadow
/etc/gshadow

ls -l /etc/passwd
ls -l /etc/group
ls -l /etc/shadow
ls -l /etc/gshadow

ls -l /etc/passwd-ls 
ls -l /etc/group-
ls -l /etc/shadow-
ls -l /etc/gshadow-

명령어의 체계
# CMD OP ARG
첫번째 오는건 무조건 명령어
두번째는 옵션
-a 짧은 옵션
–all 긴 옵션
a GNU 형식의 옵션
인자 : 파일이나 디렉토리를 받아 위치를 조정

[root@servera ~]# ls -l  /etc  | grep [-]$
-rw-r--r--.  1 root root      675 May 18  2022 group-
----------.  1 root root      540 May 18  2022 gshadow-
-rw-r--r--.  1 root root     1512 May 18  2022 passwd-
----------.  1 root root      942 May 18  2022 shadow-
-rw-r--r--.  1 root root       21 May 18  2022 subgid-
-rw-r--r--.  1 root root       21 May 18  2022 subuid-


 group-
그룹을 잘못 설정하게 되면 업데이트 되면서 기존의 모든 그룹설정이  업데이트되어 없어진다.
cat /etc/group- > /etc/group

[46] 랩 

vi bash-lab
echo ‘#!/usr/bin/bash’ >> bash-lab

[54] 

at
crontab  << * 
anacron
timer

at: 1회성 작업을 위한 스케쥴러
른 예는 방화벽 구성 작업 중인 시스템 관리자가 새 방화벽 구성이 작동했기 때문에 방화벽 설정을 10분 이내에 이전의 작업 상태로 재설정하기 위해 안전 작업 을 대기열에 추가하는 경우  << 현재 firewalld를 사용하면 이 구성은 굳이 필요없다.
방화벽 구성
at을 이용해서 10분뒤에 원복하면 된다.
현재 firewalld를 이용하는 경우에는 timer 옵션으로 원상태로 복구 가능하기 때문에 약간 틀린 예시: CMD –timeout 600 

실제 예시: 
다른 시스템이 재부팅 : 재부팅 이후에 체크, 재부팅 이후 접속
 
명령어 : at
데몬 [서비스] : atd 
[root@servera ~]# systemctl status atd
 atd.service - Deferred execution scheduler
     Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled; vendor preset: enabled)
     Active: active (running) since Sun 2024-07-21 21:47:36 EDT; 23h ago
       Docs: man:atd(8)
   Main PID: 803 (atd)
      Tasks: 1 (limit: 10799)
     Memory: 312.0K
        CPU: 13ms
     CGroup: /system.slice/atd.service
             └─803 /usr/sbin/atd -f

Jul 21 21:47:36 servera.lab.example.com systemd[1]: Started Deferred execution scheduler.





서비스 파일 설명
[root@servera ~]# systemctl status atd
atd.service - Deferred execution scheduler : 데몬[서비스]명 확인
     Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled; vendor preset: enabled)
     서비스 파일에 대해서 읽은 상태 |실제 파일 위치 | 활성화 정보 
     Active: active (running) since Sun 2024-07-21 21:47:36 EDT; 23h ago
      현재 상태 
       Docs: man:atd(8)
       사용 가능한 도움말
   Main PID: 803 (atd)
       현재 사용중인 PID 번호 확인
      Tasks: 1 (limit: 10799)
     Memory: 312.0K
        CPU: 13ms
     CGroup: /system.slice/atd.service
             └─803 /usr/sbin/atd -f

Jul 21 21:47:36 servera.lab.example.com systemd[1]: Started Deferred execution scheduler.
로그 중에 atd 와 관련있는 로그들을 추출하여 status 출력시 최신 로그를 같이 보여준다.

작업:
1 현재 시간을 확인
[root@servera log]# date   < 시간을 확인
Mon Jul 22 09:20:41 PM EDT 2024
[root@servera log]# at 09:25   < at 명령을 실행 TIMESPEC 지정
warning: commands will be executed using /bin/sh
at> logger 'test at'
at> <EOT>
job 1 at Tue Jul 23 09:25:00 2024


[root@servera log]# at 09:25  < file1   : 작업을 수동으로 입력하지 않고 파일에서 작업을 불러온다.

[root@servera log]# atq
1       Tue Jul 23 09:25:00 2024 a root
현재 지정된 작업들을 확인

[root@servera log]# at -c 1

마지막 부분에서 실제 사용한 명령을 확인 할 수 있다.

[root@servera log]# atrm 1 
at의 작업을 삭제 하는 용도

[59]
crontab

[root@servera ~]# cat /etc/crontab 
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
변수처리된 부분은 top-down 형식으로 진행되기 때문에 변수가 지정된 이후 모든 작업에 적용된다.

# For details see man 4 crontabs

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed

[1] [2] [3] [4] [5] [user-name] [command to be executed]

각 자리가 표시 하는것 
[1]: 분
[2]: 시
[3]: 일
[4]: 월
[5]: 주

각 자리가 표시 하는것 + 숫자의 범위
[1]: 분 0-59
[2]: 시 0-23
[3]: 일 1-31
[4]: 월 1-12
[5]: 주 0-6  0==7  1-5 월-금 6 토 일0,7 



각 자리가 표시 하는것 + 숫자의 범위 + 표시 되는 형식에서 알아야 하는것
주의 사항을 알아보자

[1]: 분 0-59
0분을 사용하지 말것
모든 시간의 0분에는 시스템에서 사용되는 스케쥴러들이 많이 돌아간다.
[2]: 시 0-23
0시는 제외
하루가 시작되는 시간에 모든 초기화 작업, 정보 수집이 새로 시작되는데 이때 크론을 걸게 되면 부하가 심해짐
[3]: 일 1-31
1 제외
30일,28일,27
[4]: 월 1-12
[5]: 주 0-6  0==7  1-5 월-금 6 토 일0,7 
사용하는 사람들마다 0과 7을 섞어서 사용함.
팀에서 포맷 맞춰서 사용

숫자를 이용할때 사용 가능한 형식
[1]: 분 0-59

* 모든 시간을 지정

10 : 10분이라는 시간에 지정

10,15 10분,15분이라는 시간에 지정

10-15 10,11,12,13,14,15 분이라는 시간에 지정

10-15,20 10,11,12,13,14,15,20 분이라는 시간에 지정

*/N  N분에 한번씩
*/2 2분에 한번씩
*/10 10분에 한번씩

*/N 단점:  크론탭은 1분에 한번씩 동작
*/10  10분에 한번씩 로그를 출력해야겠다.
*/10 * * * * PATH/script.log

XXXX  XX XX XX:10
XXXX  XX XX XX:20
XXXX  XX XX XX:30
XXXX  XX XX XX:40

reboot, restart : 부팅 이후 시간기준으로 10분간격
service start time XXXX  XX XX XX:16
XXXX  XX XX XX:16
XXXX  XX XX XX:26
XXXX  XX XX XX:36
XXXX  XX XX XX:46

[user-name] [command to be executed]

[user-name] 이전방식 : /etc/crontab 파일에서 사용하다보니 어떤 사용자로 실행 할 것인가를 지정
 [command to be executed] 실행 파일을 지정 실행 권한도 같이 필요.

과거에는 /etc/crontab 파일에 작성을 root 계정으로 하고 관리도 root가 진행
현재:  더이상 /etc/crontab 파일에 작성하지 않는다. 이 파일은 이제 참고용 파일로 남겨둠

각각 계정별로 작업을 한다.
1 root 계정으로 각 사용자 파일을 생성
[root@servera cron]# crontab -e -u student
2 실제 사용자 계정으로 파일을 생성
[root@servera cron]# su -  student
Last login: Mon Jul 22 02:15:38 EDT 2024 from 172.25.250.9 on pts/0
[student@servera ~]$ crontab -e 

# crontab 
-l : crontab 파일을 확인
-e : crontab 파일을 수정
-r:  crontab 파일을 삭제
-u [계정] 위 명령들을 현재 사용자가 아니라 특정 사용자로 지정하여 진행

[root@servera ~]# cd
[root@servera ~]# id
uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

[root@servera ~]# crontab -l
no crontab for root   < 현재는 크론 파일이 생성되지 않음.

[root@servera ~]# crontab -e

"/tmp/crontab.Y7L9LY" 0L, 0B   << crontab  파일의 경우는 임시파일로 생성 한뒤 실제 파일로 변환
i
*/2 * * * * logger 'test log'
esc
:wq

crontab: installing new crontab   < 정상 저장이 완료

[root@servera ~]# cd /var/spool/cron/
[root@servera cron]# pwd
/var/spool/cron
[root@servera cron]# ls
root
[root@servera cron]# file root
root: ASCII text
[root@servera cron]# cat root 
*/2 * * * * logger 'test log'
[root@servera cron]# crontab -l
*/2 * * * * logger 'test log'

[root@servera cron]# crontab -e -u student 
*/2 * * * * logger 'test log student'
[root@servera cron]# ls -l
total 8
-rw-------. 1 root root 30 Jul 22 22:17 root
-rw-------. 1 root root 38 Jul 22 22:19 student
생성된 파일의 경우에는 root 권한으로 생성 되지만 상관 없음.
실제 진행되는 프로세스는  student 파일명으로 동일한 계정에서 실행

[root@servera cron]# journalctl | grep 'test log'
Jul 22 22:18:01 servera.lab.example.com CROND[2662]: (root) CMD (logger 'test log')
Jul 22 22:18:01 servera.lab.example.com root[2662]: test log
Jul 22 22:18:01 servera.lab.example.com CROND[2660]: (root) CMDEND (logger 'test log')
Jul 22 22:20:01 servera.lab.example.com CROND[2685]: (root) CMD (logger 'test log')
Jul 22 22:20:01 servera.lab.example.com root[2685]: test log
Jul 22 22:20:01 servera.lab.example.com CROND[2680]: (root) CMDEND (logger 'test log')
Jul 22 22:20:01 servera.lab.example.com CROND[2696]: (student) CMD (logger 'test log student')
Jul 22 22:20:01 servera.lab.example.com student[2696]: test log student
Jul 22 22:20:01 servera.lab.example.com CROND[2681]: (student) CMDEND (logger 'test log student')
현재 crontab에 지정한 내용들이 정상 동작중이다.

[root@servera cron]# ls
root  student
[root@servera cron]# crontab -r 
[root@servera cron]# ls
student
[root@servera cron]# rm -rf student 
[root@servera cron]# crontab -u student -l
no crontab for student

crontab은 저장 하는 순간부터 진행

[root@servera cron]# systemctl status crond
● crond.service - Command Scheduler
     Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled)
     Active: active (running) since Sun 2024-07-21 21:47:36 EDT; 24h ago
   Main PID: 804 (crond)
      Tasks: 1 (limit: 10799)
     Memory: 1.3M
        CPU: 1.163s
     CGroup: /system.slice/crond.service
             └─804 /usr/sbin/crond -n

Jul 22 20:01:01 servera.lab.example.com CROND[2408]: (root) CMD (run-parts /etc/cron.hourly)

프로세스의 진행 시간을 확인 하는 명령어
[root@servera cron]# cd 
[root@servera ~]# dd if=/dev/zero of=/root/bigfile bs=1M count=1024
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.09995 s, 511 MB/s
[root@servera ~]# ls
bigfile  lines.txt  list  list1
[root@servera ~]# file bigfile 
bigfile: data


[root@servera ~]# time dd if=/dev/zero of=/root/bigfile bs=1M count=1024
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.4091 s, 446 MB/s

real    0m2.474s   << * 
user    0m0.003s
sys     0m0.683s

# man crond
# man -s 5 crontab
# man -s 8 crontab

[62]
시험에서 crontab 이 출제 
2.3 구문

 [65]
반복 실행 시스템 작업 예약 

[root@servera ~]# cd /etc/cron.
cron.d/   : 반복 실행될 시스템 작업에 대한 예약
cron.hourly/ :시간에 동작
cron.weekly/ :  주에 한번 동작
cron.daily/ : 일에 한번 동작
cron.monthly/ :  월에 한번 동작
[root@servera ~]# cd /etc/cron.d
[root@servera cron.d]# ls
0hourly
[root@servera cron.d]# 
[root@servera cron.d]# cat 0hourly 
# Run the hourly jobs
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
01 * * * * root run-parts /etc/cron.hourly
run-parts : 특정 디렉토리에 있는 스크립트를 실행하는 데 사용하는 명령


anacron
crontab과의 차이점: 
crontab의 경우에는 사용자 관점
anacron의 경우에는 시스템 관점
crontab의 경우는 충돌이나 재부팅등 사용이 불가능한 상황에 놓여 시간을 놓치게 된다면 해당 작업을 무시. 그 다음 시간대에 작업을 재개
anacron의 경우는  충돌이나 재부팅등 사용이 불가능한 상황이 오게 되면 그 이후 재부팅, 충돌에 대한 해결이 된 다음 곧 바로 작업을 재개

[root@servera cron.hourly]# cat /etc/anacrontab 
# /etc/anacrontab: configuration file for anacron

# See anacron(8) and anacrontab(5) for details.

SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
# the maximal random delay added to the base delay of the jobs
RANDOM_DELAY=45
# the jobs will be started during the following hours only
START_HOURS_RANGE=3-22

#period in days    | delay in minutes  |  job-identifier  |  command
 1                                 5                                  cron.daily              nice run-parts /etc/cron.daily
 7                                 25                               cron.weekly           nice run-parts /etc/cron.weekly
@monthly                 45                                cron.monthly            nice run-parts /etc/cron.monthly
[root@servera cron.hourly]# cat /etc/anacrontab  | tail -4 | column -t

timer

init > systemd

systemd에서 사용 가능한 timer 유닛
현재 anacron의 경우에는 timer 유닛으로 모두 변경
[root@servera cron.hourly]# systemctl -t timer
  UNIT                         LOAD   ACTIVE SUB     DESCRIPTION                           
  dnf-makecache.timer          loaded active waiting dnf makecache --timer
  logrotate.timer              loaded active waiting Daily rotation of log files
  mlocate-updatedb.timer       loaded active waiting Updates mlocate database every day
  systemd-tmpfiles-clean.timer loaded active waiting Daily Cleanup of Temporary Directories

timer의 장점:
crontab은 1분에 한번 작용
timer는 초단위 가능

/tmp
/var/tmp

[68] 실습

[84]
시스템 로그 아키텍처 설명

로그 : 시스템 감사 및 문제 해결에 사용 , 이벤트에 대한 기록
로그는 보통 텍스트 파일로 구성 되어있지만 모두가 그런것은 아님

[root@servera ~]# cd /var/log
[root@servera log]# ls
audit                  dnf.librepo.log  maillog   spooler
boot.log               dnf.log          messages  sssd
boot.log-20240722      dnf.rpm.log      private   tallylog
btmp                   firewalld        qemu-ga   tuned
chrony                 hawkey.log       README    wtmp
cloud-init.log         insights-client  rhsm
cloud-init-output.log  kdump.log        samba
cron                   lastlog          secure
[root@servera log]# file * | grep -v  empty | grep -v directory | grep -v ASCII | grep -v text | grep -v symbolic
lastlog:               data
wtmp:                  data
 
data 파일의 경우에는 텍스트가 아니기 때문에 바로 읽을수 없음
특정 명령을 이용해야만 가능한 경우들도 있다.
로그 파일이든 뭐든 사용자가 직접 생성한 파일이 아닌 경우에는 
file 명령을 통해서 형식을 확인하는 것이 좋다.
[root@servera log]# file lastlog
lastlog: data
[root@servera ~]# ls
bigfile  lines.txt  list  list1
[root@servera ~]# file bigfile 
bigfile: data

[root@servera ~]# journalctl  현재부팅 이후부터 모든 로그를 가지고 있음
[root@servera ~]# journalctl -f 최근의 로그만 확인


systemd-journald  재부팅 후 유지되지 않는 파일 시스템에 저장 /run 밑에서 사용을 하기 때문에 그렇다.

syslog / rsyslog
사용되는 용어들도 알아야 하고 나오는 메시지도 봐야 하고 ..

syslog 기능 개요
메세지 종류  설  명
authpriv    개인 인증을 요하는 프로그램 유형이 발생한 메세지(EX: su, telnet, ssh)
cron        crontab(crond), at(atd) 프로그램이 발생한 메세지(EX: crontab, at)
daemon      시스템 데몬이 생성한 메세지. (EX: telnetd, ftpd) 
kern        커널이 발생한 메세지
lpr         프린트 유형의 프로그램이 발생한 메세지
mail        메일시스템이 발생한 메세지.
mark        syslogd 데몬에 의해 생성된 일정한 시간간격의 반복적인 메세지
news        유즈넷 뉴스 프로그램 유형이 발생한 메세지
security(auth)  인증 프로그램이 생성한 메세지(EX: login)
syslog     syslog 프로그램이 생성한 메세지(EX: syslogd)
user       사용자 프로그램에 의해 생성된 메세지(EX: top, system-config-*)
uucp       UUCP(Unix to Unix Copy) 시스템이 발생한 메세지
local0-7   예약된 메세지 종류, 여분으로 남겨둔 유형(EX: local0, local1, local2, ...)
*          모든 메세지(단, mark 메세지 종류는 제외)

 메세지 난이도(Level)
메세지 레벨        설  명
0 emerg (panic)   패닉상태, 모든 사용자에게 전달되어야 할 위험한 상황의 메세지
1 alert           즉각적인 조치를 위해야 상황의 메세지
2 crit            시스템에 문제가 생기는 단계의 메세지
3 error (err)     에러가 발생하는 경우의 메세지
4 warning (warn)  주의를 요하는 경고 메세지
5 notice          특별한 주의를 요하는 에러는 아닌 메세지
6 info            통계, 기본정보 메세지
7 debug           프로그램을 디버깅할 때 생성되는 메세지

실제 로그를 수집 하기 위한 정책에 대한 파일
메시지 기록 위치
# cat /etc/rsyslog.conf

Facility : 메세지의 종류
Level : 메세지의 난이도(위험 수준)
Action : 메세지 기록 위치


/etc/rsyslog.conf의 구성
authpriv.* /var/log/secure
Facility.Level      Action

메세지 기록 위치      설  명
/var/log/messages     기록을 남길 특정한 로그 파일 선택(예: /var/log/file.log)
만약에 없는 파일에 기록을 하는 경우 파일이 없어 에러가 날 수 있음. 미리 touch로 빈 파일을 생성
/dev/console          기록을 남길 콘솔에 로그 기록 남김(예: /dev/console)
user01,root, *        특정한 사용자나 모든 사용자 선택(예: user01, *)
@hostA, @172.16.8.254 다른 호스트 선택(예: @172.16.8.254)-> 보통 로그 서버 선택

예시파일
# cat /etc/syslog.conf
# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*                                                 /dev/console
커널에 관련한 모든 메세지는 콘솔창에 출력한다.

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
*.info;mail.none;news.none;authpriv.none;cron.none      /var/log/messages
메일(mail),뉴스(news),개인인증(authpriv),크론(cron) 메세지를 제외한 대부분의 메세지를 /var/log/messages 파일에 기록한다.

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure
개인적인 인증에 관련한 부분은 /var/log/secure 파일에 기록한다.(su, sshd)

# Log all the mail messages in one place.
mail.*                                                  -/var/log/maillog
메일에 관련한 모든 메세지는 /var/log/maillog 파일에 기록한다.
 -/var/log/maillog에서 -의 기능
기록 후 파일 동기화를 생략하기 위해 -를 접두사로 붙여 지정 가능
시스템이 쓰기를 시도 할 때 충돌 할 가능성이 있다. 성능에 따라서 사용 할 때 가 있음.

# Log cron stuff
cron.*                                                  /var/log/cron
크론(cron) 메세지 모두를 /var/log/cron 파일에 기록한다.

# Everybody gets emergency messages
*.emerg                                                 *
모든 경우 위험한 메세지(패닉 상태)는 모든 사용자에게 뿌린다.

# Save news errors of level crit and higher in a special file.
uucp,news.crit                                          /var/log/spooler
uucp,news에 대한 critical 이상 메세지는 /var/log/spooler 파일에 기록한다.

# Save boot messages also to boot.log
local7.*                                                /var/log/boot.log
미리 예약된 local7 종류에 대한 모든 메세지(부팅시의 메세지)를 /var/log/boot.log 파일에 기록한다.

#
# INN
#
news.=crit                                        /var/log/news/news.crit
news.=err                                         /var/log/news/news.err
news.notice                                       /var/log/news/news.notice

각 로그파일은 var/log 디렉토리에 존재한다.

로그파일                      설   명
(T) /var/log/messages      메일(mail), 뉴스(news), 인증(authpriv), 크론(cron) 메세지를 제외한 시스템의 전반적인 메세지를 기록하는 로그파일이다. 리눅스에서는 가장 많은 메세지를 담고 있는 파일이다. 
(TUI) # tail -f /var/log/messages 
(T) /var/log/secure        개인인증을 기록하는 로그파일이다.(EX: su, telnet, ssh)
(T) /var/log/dmesg         시스템이 부팅할때 메세지를 기록하는 로그 파일이다. dmesg 명령어가 이 파일을 참조하여 정보를 출력한다. # dmesg 
(D) /var/log/lastlog       사용자의 가장 마지막에 로그인한 시간을 기록하는 로그 파일이다. 바이너리 파일이므로 안의 내용을 cat 명령어를 통해 확인할 수 없다. lastlog 명령어가 이 파일을 참조하여 정보를 출력한다. # lastlog 
(T) /var/log/cron          crontab, at 명령어를 통해 실행했던 작업을 기록하는 로그 파일이다.
- crond -> crontab CMD
- atd   -> at CMD
(T) /var/log/maillog       postfix 메일 관련 작업을 기록하는 로그 파일이다.
(T) /var/log/xferlog       FTP 서버에서 업로드/다운로드을 기록하는 로그 파일이다.
(D) /var/log/wtmp          사용자의 로그인/로그아웃 시간을 기록하는 로그파일이다. 데이터 파일이므로 안의 내용을 cat 명령어를 통해 확인할 수 없다. last 명령어가 이 파일을 참조하여 정보를 출력한다. # last   (# last oracle)
(D) /var/run/utmp          현재 로그인한 사용자 정보를 기록하는 로그 파일이다. 데이터 파일이므로 안의 내용을 cat 명령어를 통해 확인 할 수 없다. who 명령어가 이 파일을 참조하여 정보를 출력한다. # who

logrotate
로그파일은 시간이 지남에따라 계속 계속 커진다.
1~2M 일때는 사실 상관 없음. 하지만 수많은 로그 데이터가 쌓이게 되면 파일을 오픈 하는 것도 힘들다.

32bit system : 코드 파일 ? 2.4G
open: 4시간 
하나의 파일이 너무 커지는 것을 방지하기 위해 logrotate를 사용한다.
logrotate를 통해 순환 파일로 제공
이전 방식: /var/log/messages.0 .1 .2 .3 
 /var/log/messages


현재 방식: var/log/messages-20220320

로그 데이터
Mar 20 20:11:48 localhost sshd[1433]: Failed password for student from 172.25.0.10 port 59344 ssh2

Mar 20 20:11:48 : 시간 timestamp
localhost  host 
sshd[1433]: id 사용자나 데몬이름 + PID
Failed password for student from 172.25.0.10 port 59344 ssh2 : 해당 로그의 상세한 내용
lastb

보통은logrotate를 통해 이동한 로그 파일들은 삭제 되기전에 tar 명령어를 통해 특정 디렉토리로 이동, 일정시간 저장 한 뒤에 ISO 이미지로 생성
cp 복사 > 시간 현재 시간 업데이트
tar -> 시간+ 권+ 소 + + 기존 파일 그대로 가지고 이동
컨테이너로 가면서 tar 명령어가 더 많이 사용

로그 이벤트 모니터링 방법
# tail -f /path/to/file : 일반 파일로 저장된 내용을 확인 하기 위해 사용
[root@servera log]# journalctl -f   < systemd-journal에서 나오는 데이터를 바로 확인

[104]
저널 보존

저널의 경우에는 부팅시 - 종료시까지 사용하고 기본 값은 삭제
/etc/systemd/ journald.conf 옵션을 조정하여 영구 보관 할 수 있도록 만들어야 함
#Storage=auto
auto :  /var/log/journal 디렉토리가 존재 한다면 systemd가 영구 보관용 데이터를 사용하고 없다면 /run/log 에서 처리
persistent : /var/log/journal 생성 부팅-종료시까지의 모든 데이터를 보관

필요하다면 저널 영구 저장 장치에 대한 작업을 실시한다.
ansible을 사용하다보니까 초기 구축시에 해당 작업을 완료.

NTP : network time protocol
많은 네트워크 프로그램들은 시간 동기화가 필요하게 된다. 네트워크 상에서 서로 연동하는 시스템들 간에 시간이 일치 하지 않게 된다면 다수의 시스템 장애처리, 성능카운트, 분석, 로깅등 수많은 문제점을 갖게된다.

시간 서버의 발전
이전에는 rdate 사용
현재는 ntp

[root@servera ~]# timedatectl
               Local time: Tue 2024-07-23 03:42:49 EDT   현재 시스템 시간
           Universal time: Tue 2024-07-23 07:42:49 UTC UTC의 시간 
                 RTC time: Tue 2024-07-23 07:42:49 하드웨어 시간
                Time zone: America/New_York (EDT, -0400) 현재 서버의 타임존 
System clock synchronized: yes  시간 동기화가 되어 있는지 확인
              NTP service: active  NTP 서비스가 실행중인지 
          RTC in local TZ: no

# date 월일시분
[root@servera ~]# date 06121300 
Wed Jun 12 01:00:00 PM EDT 2024

[root@servera ~]# timedatectl set-time 13:00:00
Failed to set time: Automatic time synchronization is enabled

[root@servera ~]# timedatectl set-time 13:00:00
Failed to set time: Automatic time synchronization is enabled
[root@servera ~]# timedatectl set-ntp 
false  true   
[root@servera ~]# timedatectl set-ntp false 
[root@servera ~]# timedatectl set-time 13:00:00

[root@servera ~]# timedatectl set-time '2012-10-30 13:00:00'
[root@servera ~]# timedatectl 
               Local time: Tue 2012-10-30 13:00:04 EDT
           Universal time: Tue 2012-10-30 17:00:04 UTC
                 RTC time: Tue 2012-10-30 17:00:04
                Time zone: America/New_York (EDT, -0400)
System clock synchronized: no
              NTP service: inactive
          RTC in local TZ: no

위의 내용은 timedatectl 명령을 이용하여 수동으로 시간을 변경
보통은 이렇게 하지 않음 NTP 서버가 동작하고 해당 서버를 바라보게 하기 때문에 이렇게 사용하지는 않는다.
[root@servera ~]# dnf -y remove chrony
chrony 삭제 후 진행

[root@servera ~]# ls -l $(which yum)
lrwxrwxrwx. 1 root root 5 Mar 21  2022 /usr/bin/yum -> dnf-3
[root@servera ~]# ls -l $(which dnf)
lrwxrwxrwx. 1 root root 5 Mar 21  2022 /usr/bin/dnf -> dnf-3

[root@servera ~]# dnf list
[root@servera ~]# dnf repolist
[root@servera ~]# dnf clean all

[root@servera ~]# dnf install telnetRed Hat Enterprise Linux 9.0 BaseOS (dvd)   779 kB/s | 2.7 kB     00:00    
Red Hat Enterprise Linux 9.0 AppStream (dvd 1.1 MB/s | 2.8 kB     00:00    
Dependencies resolved.
============================================================================
 Package Arch    Version          Repository                           Size
============================================================================
Installing:
 telnet  x86_64  1:0.17-85.el9    rhel-9.0-for-x86_64-appstream-rpms   66 k

Transaction Summary
============================================================================
Install  1 Package

Total download size: 66 k
Installed size: 121 k
Is this ok [y/N]: y
Downloading Packages:
telnet-0.17-85.el9.x86_64.rpm               398 kB/s |  66 kB     00:00    
----------------------------------------------------------------------------
Total                                       394 kB/s |  66 kB     00:00     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                    1/1 
  Installing       : telnet-1:0.17-85.el9.x86_64                        1/1 
  Running scriptlet: telnet-1:0.17-85.el9.x86_64                        1/1 
  Verifying        : telnet-1:0.17-85.el9.x86_64                        1/1 

Installed:
  telnet-1:0.17-85.el9.x86_64                                               

Complete!
[root@servera ~]# 
[root@servera ~]# dnf -y install ftp 
Red Hat Enterprise Linux 9.0 BaseOS (dvd)   628 kB/s | 2.7 kB     00:00    
Red Hat Enterprise Linux 9.0 AppStream (dvd 1.3 MB/s | 2.8 kB     00:00    
Dependencies resolved.
============================================================================
 Package
       Arch     Version          Repository                            Size
============================================================================
Installing:
 ftp   x86_64   0.17-89.el9      rhel-9.0-for-x86_64-appstream-rpms    64 k

Transaction Summary
============================================================================
Install  1 Package

Total download size: 64 k
Installed size: 112 k
Downloading Packages:
ftp-0.17-89.el9.x86_64.rpm                  1.1 MB/s |  64 kB     00:00    
----------------------------------------------------------------------------
Total                                       1.1 MB/s |  64 kB     00:00     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                    1/1 
  Installing       : ftp-0.17-89.el9.x86_64                             1/1 
  Running scriptlet: ftp-0.17-89.el9.x86_64                             1/1 
  Verifying        : ftp-0.17-89.el9.x86_64                             1/1 

Installed:
  ftp-0.17-89.el9.x86_64                                                    

Complete!
[root@servera ~]# 

install  : 설치
remove  : 삭제

ntp를 구성하여 클라이언트로서 동작 시키기
1 패키지 설치
# dnf -y install chrony
[root@servera ~]# rpm -ql chrony
chrony 패키지에서 추출된 파일 목록 확인
[root@servera ~]# rpm -qlc chrony
설정 파일만 모아보기
[root@servera ~]# rpm -qld chrony
문서파일만 모아보기
/etc/chrony.conf : chrony에서의 설정 파일
해당 파일에서 클라이언트 구성은 1번 섹션이다.
server / pool
server : 단독 서버 
pool : 다수의 서버로 구성되어 있다.
server 2.rhel.pool.ntp.org iburst
server : 서버를 지정
2.rhel.pool.ntp.org : 서버로 지정할 호스트/ IP 
iburst : 타임 서버들은 초기 서비스에 걸리는 동기화 시간이 존재한다. 서비스를 시작하고 외부, 내부망에서 네트워크를 확인한 뒤 패킷을 보내 동기화를 시작
패킷을 전송하고 다음 패킷까지 걸리는 시간은 16초가 걸린다. 이 시간을 줄이기 위해서 한번에 8개를 동시에 전송하라는 옵션이다.
[root@servera ~]# vi  /etc/chrony.conf
#pool 2.rhel.pool.ntp.org iburst  <  기존 라인 주석 처리
server classroom.example.com iburst 
:wq

여기부터 따라하면 됩니다.
[root@servera ~]# timedatectl set-ntp false 
[root@servera ~]# timedatectl set-time '2012-10-30 13:00:00'
[root@servera ~]# systemctl daemon-reload   < systemd에 변경된 파일이 있으면 업데이트
[root@servera ~]# systemctl enable --now chronyd 
Created symlink /etc/systemd/system/multi-user.target.wants/chronyd.service → /usr/lib/systemd/system/chronyd.service.
사용한 명령:  systemctl enable --now chronyd 
1 systemctl start chronyd 
2 systemctl enable chronyd 
[root@servera ~]# systemctl is-active chronyd
active
[root@servera ~]# systemctl is-enabled chronyd
enabled

[root@servera ~]# systemctl status chronyd
● chronyd.service - NTP client/server
     Loaded: loaded (/usr/lib/systemd/system/chronyd.service; enabled; vendor preset: enabled)
     Active: active (running) since Tue 2012-10-30 13:00:38 EDT; 11 years 8 months ago
       Docs: man:chronyd(8)
             man:chrony.conf(5)
    Process: 27544 ExecStart=/usr/sbin/chronyd $OPTIONS (code=exited, status=0/SUCCESS)
   Main PID: 27546 (chronyd)
      Tasks: 1 (limit: 10799)
     Memory: 804.0K
        CPU: 21ms
     CGroup: /system.slice/chronyd.service
             └─27546 /usr/sbin/chronyd -F 2

[root@servera ~]# timedatectl 
               Local time: Tue 2024-07-23 04:24:32 EDT
           Universal time: Tue 2024-07-23 08:24:32 UTC
                 RTC time: Tue 2024-07-23 08:24:32
                Time zone: America/New_York (EDT, -0400)
System clock synchronized: yes   <<< 싱크가 완료
              NTP service: active    <<< 활성화
          RTC in local TZ: no

다른 터미널을 열어서 root 권한으로 아래의 명령을 실행한다.
[root@servera ~]# while true; do date 06191300 ; sleep 1; done

[root@servera ~]# chronyc sources
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^? 172.25.254.254                0   6   377     -     +0ns[   +0ns] +/-    0ns

[root@servera ~]# chronyc sources -v

  .-- Source mode  '^' = server, '=' = peer, '#' = local clock.
 / .- Source state '*' = current best, '+' = combined, '-' = not combined,
| /             'x' = may be in error, '~' = too variable, '?' = unusable.
||                                                 .- xxxx [ yyyy ] +/- zzzz
||      Reachability register (octal) -.           |  xxxx = adjusted offset,
||      Log2(Polling interval) --.      |          |  yyyy = measured offset,
||                                \     |          |  zzzz = estimated error.
||                                 |    |           \
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^? 172.25.254.254                0   6   377     -     +0ns[   +0ns] +/-    0ns


[root@servera ~]# watch -n 1 'chronyc sources -v'
시간 동기화를 모니터링
[root@servera ~]# timedatectl set-ntp false ; date 06191300 ; timedatectl set-ntp true 



  .-- Source mode  '^' = server, '=' = peer, '#' = local clock.
 / .- Source state '*' = current best, '+' = combined, '-' = not combined,
| /             'x' = may be in error, '~' = too variable, '?' = unusable.
||                                                 .- xxxx [ yyyy ] +/- zzzz
||      Reachability register (octal) -.           |  xxxx = adjusted offset,
||      Log2(Polling interval) --.      |          |  yyyy = measured offset,
||                                \     |          |  zzzz = estimated error.
||                                 |    |           \
MS Name/IP address         Stratum Poll Reach LastRx Last sample
===============================================================================
^* 172.25.254.254                2   6    17    32  -1154ns[-3900ns] +/- 3832us
동기화가 완료 되면 Reach 값이 377로 유지된다.

다시한번 이렇게 구성
[root@servera ~]# timedatectl set-ntp false ; date 06191300

[root@servera ~]# timedatectl set-ntp true  
[root@servera ~]# chronyc -a makestep 
200 OK
200 OK chronyc -a makestep 이 명령어는 NTP 서버와 최대한 근접하게 시간을 수정하여 동기화 되는 시간을 줄여줄수 있다.

타임존을 변경해야 하는 경우에는 아래와 같이 사용한다.
[root@servera ~]# timedatectl set-timezone Asia/Seoul 
[root@servera ~]# timedatectl
               Local time: Tue 2024-07-23 17:35:30 KST
           Universal time: Tue 2024-07-23 08:35:30 UTC
                 RTC time: Tue 2024-07-23 08:35:30
                Time zone: Asia/Seoul (KST, +0900)
System clock synchronized: yes
              NTP service: active
          RTC in local TZ: no


MS Name/IP address         Stratum Poll Reach LastRx Last sample
===============================================================================
^* 172.25.254.254                2   6   377    49  +5620ns[  +17us] +/- 4601us

Reach 이 377이면 동기화가 완료 되었다 라고 보면 된다.

시험에서는 설정 파일을 구성하고 ntp 서비스에서 대해 enabled만 구성되면 끝
패키지 설치 / 설정 파일 변경 / enabled 확인

연습문제는 내일 오전에 하고
 
storage 부터 7장 나가도록 하겠습니다.

https://meet.google.com/hqd-uhrn-tpb

114 / 118 
시험용 NTP * 
journalctl 
[217]

장치 인식부터 마운트까지의 디스크 관리
현재 과정에서는 장치인식은 따로 하지 않는다. 되어 있다고 가정

원판형 디스크 
장치 인식 [글자만]
—-----------------------------------
파티션 작업
파일시스템 포맷
마운트
오버마운트 주의사항
fstab 파일 작성
재부팅 -> 마운트 확인

디스크

IDE X
S-ATA
SCSI
SAS
SSD
Nvme
PCI - connect
인터페이스는 위와 같이 분류

https://babytiger.netlify.app/posts/hdd/

흔히 사용하는 S-ATA 디스크를 분해하였을때는 다음과 같은 모양으로 나타나게 된다.
스핀들(Spindle) : 플래터를 돌러주는 축
스핀들모터 - 스핀들과 완벽하게 물려있어 스핀들을 회전시켜 스핀들과 함께 플래터를 회전 시키는 역할을 한다.
플래터(Platters) : 원판(플랫터), 데이터가 저장되는 공간
헤드(Heads) : 데이터를 읽어들이는 부분
헤드 암(Head actuator arm) : 데이터를 읽어 들이는 팔




윈도우에서 사용되는 파티션 이름[디스크]
C:\ D:\..

리눅스에서 사용되는 파티션 이름
-  디스크이름 
SCSI DISK 
/dev/sda /dev/sdb /dev/sdc …. 

IDE DISK ( 이전에 사용하던 디스크 방식) 
/dev/hda /dev/hdb /dev/hdc

Nvme DISK 
/dev/nvme0 /dev/nvme1 /dev/nvme2
    
가상디스크  
/dev/vda /dev/vdb /dev/vdc
가상디스크 버전 업 
/dev/xvda /dev/xvdb /dev/xvdc
    
-  파티션이름 
Primaty Patition(1-4)     주파티션 
Extended Partition(5-15) 확장파티션 
Logical Patition     논리파티션 

-  리눅스 최대 파티션 개수 
MBR
15 partitions : /dev/sda1~15 
주 파티션 4 (확장파티션1개 포함)
확장파티션 : 논리파티션을 담을 수 있는 공간
논리 파티션 5-15

주 파티션           
주파티션(Primary Partition), 기본 파티션으로 더 이상 쪼갤 수 없는 파티션이다. 
하나의 하드디스크에는 주 파티션과 확장 파티션을 네 개까지만 만들 수 있다는 제한이 있다. 
네 개 이상의 파티션이 필요한 경우 확장 파티션을 만들어 그 안에 논리 파티션을 두게 된다.
확장 파티션
하드 디스크를 여러 개의 파티션으로 나누고자 할 때 만드는 파티션이다.
확장 파티션은 저장 공간이 없으며, 안에 논리 파티션을 만들 수 있게 해주는 커다란 그릇 역할만 한다.

파티션: 영역을 나누기 위함
루트파티션의 파괴시 다중 파티션으로 자료 보호, 백업의 용이성
파일 시스템 점검 시간 축소

SCSI 컨트롤러에 연결되어 있는 순서에 따라 하드디스크를 표현

IDE
                          Window         Linux 
Primary master HardDisk   disk0          /dev/hda
Primary slave HardDisk    disk1          /dev/hdb
Secondary master HardDisk disk2          /dev/hdc
Secondary slave HardDisk  disk3          /dev/hdd

SCSI
                          Window         Linux 
Primary master HardDisk   disk0          /dev/sda
Primary slave HardDisk    disk1          /dev/sdb
Secondary master HardDisk disk2          /dev/sdc
Secondary slave HardDisk  disk3          /dev/sdd

GPT: 128개의 파티션
2T 이상 DISK에서 사용

장치 인식
# lsblk
# lspci | grep -i scsi
# lsscsi
# lsscsi -d 
# lsscsi -l
# lsscsi -g

[0:0:0:0]
H : Host Adapter ID
C : SCSI Channel on Host Adapter 
T : ID 
L : LUN

[root@servera ~]# find /sys/devices -name scan -exec ls -l {} \;
--w-------. 1 root root 4096 Jul 23 16:14 /sys/devices/pci0000:00/0000:00:01.1/ata1/host0/scsi_host/host0/scan
--w-------. 1 root root 4096 Jul 23 16:14 /sys/devices/pci0000:00/0000:00:01.1/ata2/host1/scsi_host/host1/scan

# echo “- - -” >  /sys/devices/pci0000:00/0000:00:01.1/ata1/host0/scsi_host/host0/scan

echo에서 사용한 “- - -”에 들어가는 인자값은 뒤의 인수에서 자동으로 추가된다. 해당 값을 알아보자. 첫 번째 기호 : Channel Number 두 번째 기호 : SCSI Target ID 세 번째 기호 : LUN Values 자세한 내용은 여기에 : https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/online_storage_reconfiguration_guide/scanning-storage-interconnects

# echo 1 > /sys/block/sdc/device/delete : 블록 디바이스의 이름을 정확히 지정해야 한다.

—------------------------------------------------------------------------------------------
디바이스는 등록되어 있다.
[root@servera ~]# lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sr0     11:0    1  558K  0 rom  
vda    252:0    0   10G  0 disk 
├─vda1 252:1    0    1M  0 part 
├─vda2 252:2    0  200M  0 part /boot/efi
├─vda3 252:3    0  500M  0 part /boot
└─vda4 252:4    0  9.3G  0 part /
vdb    252:16   0    5G  0 disk 
vdc    252:32   0    5G  0 disk 
vdd    252:48   0    5G  0 disk 

현재 시스템의 장치는 크게 두분류
DVDROM [sr0]/ DISK[vda..]
disk로만 나오게 되면 아직 사용하지 않은 상태
파티션이 붙어있는 vda의 경우에는 파티셔닝이 되어 사용중

[root@servera ~]# lsblk --fs
NAME FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
sr0  iso966 Jolie config-2
                        2024-07-22-01-47-15-00                              
vda                                                                         
├─vda1
│                                                                           
├─vda2
│    vfat   FAT16       7B77-95E7                             192.8M     3% /boot/efi
├─vda3
│    xfs          boot  5e75a2b9-1367-4cc8-bb38-4d6abc3964b8  334.7M    32% /boot
└─vda4
     xfs          root  fb535add-9799-4a27-b8bc-e8259f39a767    5.7G    38% /
vdb                                                                         
vdc                                                                         
vdd 
–fs 명령을 통하여 UUID를 같이 출력

[root@servera ~]# lsblk --fs /dev/vda4
NAME FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
vda4 xfs          root  fb535add-9799-4a27-b8bc-e8259f39a767    5.7G    38% /
한개의 디스크만 명시하여 사용가능

[root@servera ~]# blkid
/dev/sr0: BLOCK_SIZE="2048" UUID="2024-07-22-01-47-15-00" LABEL="config-2" TYPE="iso9660"
/dev/vda4: LABEL="root" UUID="fb535add-9799-4a27-b8bc-e8259f39a767" BLOCK_SIZE="512" TYPE="xfs" PARTUUID="6264d520-3fb9-423f-8ab8-7a0a8e3d3562"
/dev/vda2: SEC_TYPE="msdos" UUID="7B77-95E7" BLOCK_SIZE="512" TYPE="vfat" PARTUUID="68b2905b-df3e-4fb3-80fa-49d1e773aa33"
/dev/vda3: LABEL="boot" UUID="5e75a2b9-1367-4cc8-bb38-4d6abc3964b8" BLOCK_SIZE="512" TYPE="xfs" PARTUUID="cb07c243-bc44-4717-853e-28852021225b"
/dev/vda1: PARTUUID="fac7f1fb-3e8d-4137-a512-961de09a5549"

[root@servera ~]# df 
Filesystem     1K-blocks    Used Available Use% Mounted on
devtmpfs          863980       0    863980   0% /dev
tmpfs             908696       0    908696   0% /dev/shm
tmpfs             363480    5120    358360   2% /run
/dev/vda4        9756652 3750508   6006144  39% /
/dev/vda3         506528  163796    342732  33% /boot
/dev/vda2         204580    7148    197432   4% /boot/efi
tmpfs             181736       0    181736   0% /run/user/1000
tmpfs             181736       0    181736   0% /run/user/0
현재 마운트 된 자원을 확인

[root@servera ~]# df -h
Filesystem      Size  Used Avail Use% Mounted on
devtmpfs        844M     0  844M   0% /dev
tmpfs           888M     0  888M   0% /dev/shm
tmpfs           355M  5.0M  350M   2% /run
/dev/vda4       9.4G  3.6G  5.8G  39% /
/dev/vda3       495M  160M  335M  33% /boot
/dev/vda2       200M  7.0M  193M   4% /boot/efi
tmpfs           178M     0  178M   0% /run/user/1000
tmpfs           178M     0  178M   0% /run/user/0
자원의 용량을 사람이 보기 좋게 확인

[root@servera ~]# df -hT
Filesystem     Type      Size  Used Avail Use% Mounted on
devtmpfs       devtmpfs  844M     0  844M   0% /dev
tmpfs          tmpfs     888M     0  888M   0% /dev/shm
tmpfs          tmpfs     355M  5.0M  350M   2% /run
/dev/vda4      xfs       9.4G  3.6G  5.8G  39% /
/dev/vda3      xfs       495M  160M  335M  33% /boot
/dev/vda2      vfat      200M  7.0M  193M   4% /boot/efi
tmpfs          tmpfs     178M     0  178M   0% /run/user/1000
tmpfs          tmpfs     178M     0  178M   0% /run/user/0
파일시스템 형식도 확인

[root@servera ~]# df -hT /
Filesystem     Type  Size  Used Avail Use% Mounted on
/dev/vda4      xfs   9.4G  3.6G  5.8G  39% /
특정한 마운트 포인트만 확인

[root@servera ~]# df -hT | grep -v tmp
Filesystem     Type      Size  Used Avail Use% Mounted on
/dev/vda4      xfs       9.4G  3.6G  5.8G  39% /
/dev/vda3      xfs       495M  160M  335M  33% /boot
/dev/vda2      vfat      200M  7.0M  193M   4% /boot/efi
임시 파일시스템을 제거

[219]
파티션 관리
관리자는 파티션 편집기 프로그램을 사용하여 파티션 생성, 파티션 삭제, 파티션 유형 변경 등 디스크의 파티 션을 변경할 수 있습니다. 
Red Hat Enterprise Linux 명령줄의 표준 파티션 편집기는 parted입니다. 
하지만 우리는 수업에서 그리고 현장에서 fdisk 입니다.
MBR 파티셔닝 체계 또는 GPT 파티셔닝 체계를 사용하는 스토리지와 함께 parted 파티션 편집기를 사용할 수 있습니다. parted 명령은 수정할 전체 스토리지 장치 또는 디스크를 나타내는 장치 이름을 첫 번째 인수로 사용하고 그 뒤에 하위 명령을 사용합니다. 다음 예에서는 print 하위 명령을 사용하여 /dev/vda 블록 장치(시스템 에서 감지한 첫 번째 '가상화된 I/O' 디스크)인 디스크의 파티션 테이블을 표시합니다.


아 그럼 왜 fdisk인가?
p
parted의 위험성 때문:
fdisk : 모든 작업을 메모리 상에서 작업한 다음 특정명령[w]실제 저장이 되는 방식
Welcome to fdisk (util-linux 2.37.4).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.
parted는 fdisk와 달리 명령을 내리는 순간 작업이 진행

이용가능한 파티션 프로그램
fdisk : 과거부터 이용하던 표준 파티셔닝 프로그램
cfdisk: fdisk의 TUI 버전
parted : RHEL 표준 파티셔닝 프로그램 [ansible쪽에서는 parted를 이용]
gdisk: parted가 들어오기전에 GPT 지원을 위해 사용하던 프로그램 현재는 이용하지 않음
sfdisk: 파티션 구조를 가지고 다른 파티션에 동일하게 적용

디스크 초기화를 위해서는 dd 명령을 다시 이용
fdisk 특징: 메모리상에서 작업된다.
그렇기 때문에 실수를 하더라도 안전하다. 단점: 자동화로 구성하기는 꽤 까다롭다.
예시:  echo -e "n\np\n1\n\n\nt\n8e\nw" | fdisk /dev/sdX

fdisk에서 사용되는 옵션
-l : List the partition tables * 
-v : Print version number of fdisk program and exit
-s : The size of the partition (in blocks) is printed on the standard output
-b sectorsize : Specify the sector size of the disk

예시:
# fdisk /dev/device : fdisk 프로그램으로 진입
# fdisk -l /dev/device : 현재 디바이스의 파티셔닝 상태 확인
 # fdisk -l : 전체 블록 디바이스의 파티셔닝 상태 확인

fdisk의 경우에는 이미 파티셔닝이 되어 있는 경우 진입하자 마자 경고가 뜬다.

여기서 부터 시작
[root@servera ~]# fdisk /dev/vdb

Welcome to fdisk (util-linux 2.37.4).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0x16e59f00.


Command (m for help): m
기능들 중에 필요한 것만 빼도록 하겠습니다.
Help:

  DOS (MBR)
   a   toggle a bootable flag    부트 가능한 플래그로 변경 (부트 파티션 저장)
   b   edit nested BSD disklabel bsd 디스크 레이블편집
   c   toggle the dos compatibility flag 도스 호환 플래그로 변경

  Generic
   d   delete a partition 파티션 삭제
   F   list free unpartitioned space 
   l   list known partition types 알려진 파티션 목록 확인
   n   add a new partition 새로운 파티션 생성
   p   print the partition table 현재 진행중인 파티션 상태 확인
   t   change a partition type 파티션의 id를 변경 
   v   verify the partition table 파티션 테이블 확인
   i   print information about a partition

  Misc
   m   print this menu 도움말 출력
   u   change display/entry units 엔트리 단위 변경
   x   extra functionality (experts only) 추가 기능 표시

  Script
   I   load disk layout from sfdisk script file sfdisk dump 파일 입력
   O   dump disk layout to sfdisk script file sfdisk dump 파일 출력

  Save & Exit
   w   write table to disk and exit  실제 저장+빠져나가기
   q   quit without saving changes 빠져나가기

  Create a new label
   g   create a new empty GPT partition table  GPT 라벨링 변경
   G   create a new empty SGI (IRIX) partition table
   o   create a new empty DOS partition table MBR 라벨링 변경
   s   create a new empty Sun partition table

실제 사용하는것:

   g   create a new empty GPT partition table  GPT 라벨링 변경
   o   create a new empty DOS partition table MBR 라벨링 변경
   n   add a new partition 새로운 파티션 생성
   p   print the partition table 현재 진행중인 파티션 상태 확인
   t   change a partition type 파티션의 id를 변경 
   d   delete a partition 파티션 삭제


   w   write table to disk and exit  실제 저장+빠져나가기
   q   quit without saving changes 빠져나가기

참고로 구버전에서는 fdisk에서 gpt 라벨링 기능이 없음.


Command (m for help): o
Created a new DOS disklabel with disk identifier 0xdc5eea69.
mbr 영역으로 파티셔닝 하기 위한 준비

Command (m for help): p

Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos  << 
Disk identifier: 0xdc5eea69

파티셔닝 작업을 위해서 진입

전체 용량 사용으로 작업

Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free) : 주파티션
   e   extended (container for logical partitions) : 확장파티션
Select (default p): enter

Using default response p.
Partition number (1-4, default 1): enter

First sector (2048-10485759, default 2048): enter : 시작 섹터를 지정
DB ->  20480 이를 제외한 경우에는 그냥 기본값인 2048을 사용하면 된다.
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-10485759, default 10485759): enter
용량을 지정

Created a new partition 1 of type 'Linux' and of size 5 GiB.

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xdc5eea69

Device     Boot Start      End  Sectors Size Id Type
/dev/vdb1        2048 10485759 10483712   5G 83 Linux
방금 생성한 하나의 파티션으로 5G 생성


Command (m for help): q  : 빠져나가기

[root@servera ~]# fdisk /dev/vdb

Welcome to fdisk (util-linux 2.37.4).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0x1d3647ea.

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Command (m for help): 
저장을 하지 않으면 내용을 가지고 있음.

용량을 지정 1G 4G
Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-10485759, default 2048): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-10485759, default 10485759): +1G
용량을 지정   +1G 
Created a new partition 1 of type 'Linux' and of size 1 GiB.

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot Start     End Sectors Size Id Type
/dev/vdb1        2048 2099199 2097152   1G 83 Linux

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): 

Using default response p.
Partition number (2-4, default 2): 
First sector (2099200-10485759, default 2099200): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2099200-10485759, default 10485759): 

Created a new partition 2 of type 'Linux' and of size 4 GiB.
남은 용량에서 전체 파티션을 구성하는 경우에는 enter을 연속하여 입력하면 편하게 구성 가능

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start      End Sectors Size Id Type
/dev/vdb1          2048  2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 10485759 8386560   4G 83 Linux

Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.

[root@servera ~]# fdisk -l /dev/vdb
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start      End Sectors Size Id Type
/dev/vdb1          2048  2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 10485759 8386560   4G 83 Linux

sfdisk 사용방법
1 같은 서버에서 구성하기
[root@servera ~]# sfdisk -d /dev/vdb
label: dos
label-id: 0x1d3647ea
device: /dev/vdb
unit: sectors
sector-size: 512

/dev/vdb1 : start=        2048, size=     2097152, type=83
/dev/vdb2 : start=     2099200, size=     8386560, type=83

[root@servera ~]# sfdisk -d /dev/vdb | sfdisk /dev/vdc
Checking that no-one is using this disk right now ... OK

Disk /dev/vdc: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

>>> Script header accepted.
>>> Script header accepted.
>>> Script header accepted.
>>> Script header accepted.
>>> Script header accepted.
>>> Created a new DOS disklabel with disk identifier 0x1d3647ea.
/dev/vdc1: Created a new partition 1 of type 'Linux' and of size 1 GiB.
/dev/vdc2: Created a new partition 2 of type 'Linux' and of size 4 GiB.
/dev/vdc3: Done.

New situation:
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start      End Sectors Size Id Type
/dev/vdc1          2048  2099199 2097152   1G 83 Linux
/dev/vdc2       2099200 10485759 8386560   4G 83 Linux

The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.

[root@servera ~]# fdisk -l /dev/vdc
Disk /dev/vdc: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start      End Sectors Size Id Type
/dev/vdc1          2048  2099199 2097152   1G 83 Linux
/dev/vdc2       2099200 10485759 8386560   4G 83 Linux
vdc에 동일한 파티션 정보를 입력한것을 확인

2
다른서버에 저장하기
[root@servera ~]# sfdisk -d /dev/vdb  > part.info
표준 출력 리다이렉션을 통해 정보 저장
[root@servera ~]# cat part.info 
label: dos
label-id: 0x1d3647ea
device: /dev/vdb
unit: sectors
sector-size: 512

/dev/vdb1 : start=        2048, size=     2097152, type=83
/dev/vdb2 : start=     2099200, size=     8386560, type=83

[root@servera ~]# sfdisk /dev/vdd < part.info 
Checking that no-one is using this disk right now ... OK

Disk /dev/vdd: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

>>> Script header accepted.
>>> Script header accepted.
>>> Script header accepted.
>>> Script header accepted.
>>> Script header accepted.
>>> Created a new DOS disklabel with disk identifier 0x1d3647ea.
/dev/vdd1: Created a new partition 1 of type 'Linux' and of size 1 GiB.
/dev/vdd2: Created a new partition 2 of type 'Linux' and of size 4 GiB.
/dev/vdd3: Done.

New situation:
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start      End Sectors Size Id Type
/dev/vdd1          2048  2099199 2097152   1G 83 Linux
/dev/vdd2       2099200 10485759 8386560   4G 83 Linux

The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.

[root@servera ~]# fdisk -l /dev/vdd
Disk /dev/vdd: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start      End Sectors Size Id Type
/dev/vdd1          2048  2099199 2097152   1G 83 Linux
/dev/vdd2       2099200 10485759 8386560   4G 83 Linux
위 두가지 방법을 통해서 같은 디스크, 같은 서버에서 파티셔닝 작업을 할 때 이용 


vdc vdd 삭제
1
[root@servera ~]# dd if=/dev/zero of=/dev/vdc bs=1M count=100 

2
[root@servera ~]# time dd if=/dev/zero of=/dev/vdd
512byte씩 덮어쓰기가 이루어지기 때문에 용량이 크면 클수록 오래 걸린다.
dd: writing to '/dev/vdd': No space left on device
10485761+0 records in
10485760+0 records out
5368709120 bytes (5.4 GB, 5.0 GiB) copied, 92.6355 s, 58.0 MB/s

real    1m32.637s
user    0m1.753s
sys     0m16.859s

[root@servera ~]# fdisk /dev/vdb

Welcome to fdisk (util-linux 2.37.4).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start      End Sectors Size Id Type
/dev/vdb1          2048  2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 10485759 8386560   4G 83 Linux

Command (m for help): d  파티션 삭제
Partition number (1,2, default 2): 1  두개 이상 있을때는 선택

Partition 1 has been deleted.

Command (m for help): d  남은 파티션이 하나인 경우에는 바로 삭제
Selected partition 2
Partition 2 has been deleted.

확장 파티션 생성하기
Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 
First sector (2048-10485759, default 2048): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-10485759, default 10485759): +1G

Created a new partition 1 of type 'Linux' and of size 1 GiB.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): e
Partition number (2-4, default 2): 
First sector (2099200-10485759, default 2099200):  enter
확장파티션은 그 자체로 사용되는것이 아니라 공간을 지정하는 것이기 때문에 논리 파티션에서 사용할 용량을 지정
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2099200-10485759, default 10485759): 

Created a new partition 2 of type 'Extended' and of size 4 GiB.

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start      End Sectors Size Id Type
/dev/vdb1          2048  2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 10485759 8386560   4G  5 Extended
두개의 파티션으로 이미 모든 용량을 사용

Command (m for help): n
All space for primary partitions is in use.
Adding logical partition 5
First sector (2101248-10485759, default 2101248): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2101248-10485759, default 10485759): +1G

Created a new partition 5 of type 'Linux' and of size 1 GiB.

Command (m for help): n
All space for primary partitions is in use.
Adding logical partition 6
First sector (4200448-10485759, default 4200448): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (4200448-10485759, default 10485759): +1G

Created a new partition 6 of type 'Linux' and of size 1 GiB.
두개의 1G 디스크를 논리 파티션으로 생성
Command (m for help): n
All space for primary partitions is in use.
Adding logical partition 7
First sector (6299648-10485759, default 6299648): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (6299648-10485759, default 10485759): 

Created a new partition 7 of type 'Linux' and of size 2 GiB.

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start      End Sectors Size Id Type
/dev/vdb1          2048  2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 10485759 8386560   4G  5 Extended  < 실제 파티션 용량에서는 제외
/dev/vdb5       2101248  4198399 2097152   1G 83 Linux
/dev/vdb6       4200448  6297599 2097152   1G 83 Linux
/dev/vdb7       6299648 10485759 4186112   2G 83 Linux

파티션 타입 변경
리눅스는 vfs라는것을 지원

Command (m for help): t
Partition number (1,2,5-7, default 7): 

Command (m for help): t
Partition number (1,2,5-7, default 7): 7
Hex code or alias (type L to list all): L

00 Empty            24 NEC DOS          81 Minix / old Lin  bf Solaris        
01 FAT12            27 Hidden NTFS Win  82 Linux swap / So  c1 DRDOS/sec (FAT-
02 XENIX root       39 Plan 9           83 Linux            c4 DRDOS/sec (FAT-
03 XENIX usr        3c PartitionMagic   84 OS/2 hidden or   c6 DRDOS/sec (FAT-
04 FAT16 <32M       40 Venix 80286      85 Linux extended   c7 Syrinx         
05 Extended         41 PPC PReP Boot    86 NTFS volume set  da Non-FS data    
06 FAT16            42 SFS              87 NTFS volume set  db CP/M / CTOS / .
07 HPFS/NTFS/exFAT  4d QNX4.x           88 Linux plaintext  de Dell Utility   
08 AIX              4e QNX4.x 2nd part  8e Linux LVM        df BootIt         
09 AIX bootable     4f QNX4.x 3rd part  93 Amoeba           e1 DOS access     
0a OS/2 Boot Manag  50 OnTrack DM       94 Amoeba BBT       e3 DOS R/O        
0b W95 FAT32        51 OnTrack DM6 Aux  9f BSD/OS           e4 SpeedStor      
0c W95 FAT32 (LBA)  52 CP/M             a0 IBM Thinkpad hi  ea Linux extended 
0e W95 FAT16 (LBA)  53 OnTrack DM6 Aux  a5 FreeBSD          eb BeOS fs        
0f W95 Ext'd (LBA)  54 OnTrackDM6       a6 OpenBSD          ee GPT            
10 OPUS             55 EZ-Drive         a7 NeXTSTEP         ef EFI (FAT-12/16/
11 Hidden FAT12     56 Golden Bow       a8 Darwin UFS       f0 Linux/PA-RISC b
12 Compaq diagnost  5c Priam Edisk      a9 NetBSD           f1 SpeedStor      
14 Hidden FAT16 <3  61 SpeedStor        ab Darwin boot      f4 SpeedStor      
16 Hidden FAT16     63 GNU HURD or Sys  af HFS / HFS+       f2 DOS secondary  
17 Hidden HPFS/NTF  64 Novell Netware   b7 BSDI fs          fb VMware VMFS    
18 AST SmartSleep   65 Novell Netware   b8 BSDI swap        fc VMware VMKCORE 
1b Hidden W95 FAT3  70 DiskSecure Mult  bb Boot Wizard hid  fd Linux raid auto
1c Hidden W95 FAT3  75 PC/IX            bc Acronis FAT32 L  fe LANstep        
1e Hidden W95 FAT1  80 Old Minix        be Solaris boot     ff BBT            

Aliases:
   linux          - 83   *
   swap           - 82  * 
   extended       - 05
   uefi           - EF
   raid           - FD
   lvm            - 8E *
   linuxex        - 85
Hex code or alias (type L to list all):  82   < swap 파티션으로 변경

Changed type of partition 'Empty' to 'Linux swap / Solaris'.

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start      End Sectors Size Id Type
/dev/vdb1          2048  2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 10485759 8386560   4G  5 Extended
/dev/vdb5       2101248  4198399 2097152   1G 83 Linux
/dev/vdb6       4200448  6297599 2097152   1G 83 Linux
/dev/vdb7       6299648 10485759 4186112   2G 82 Linux swap / Solaris  < 변경된 내용을 확인

일단 기존 생성된 파일시스템을 모두 삭제
두개만 남김.

Command (m for help): d
Partition number (1,2,5, default 5): 2   확장 파티션을 삭제하게 되면 내부의 논리 파티션도 모두 삭제 되기 때문에 조심해서 삭제 !

Partition 2 has been deleted.

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot Start     End Sectors Size Id Type
/dev/vdb1        2048 2099199 2097152   1G 83 Linux

Command (m for help): d
Selected partition 1
Partition 1 has been deleted.

파일 시스템 생성에 필요한 구조
/dev/vdb1 1G
/dev/vdb2 1G

Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-10485759, default 2048): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-10485759, default 10485759): +1G

Created a new partition 1 of type 'Linux' and of size 1 GiB.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2-4, default 2): 
First sector (2099200-10485759, default 2099200): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2099200-10485759, default 10485759): +1G

Created a new partition 2 of type 'Linux' and of size 1 GiB.

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start     End Sectors Size Id Type
/dev/vdb1          2048 2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 4196351 2097152   1G 83 Linux

Command (m for help): w

The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.

작업 내역 확인
[root@servera ~]# fdisk -l /dev/vdb
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start     End Sectors Size Id Type
/dev/vdb1          2048 2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 4196351 2097152   1G 83 Linux
[root@servera ~]# lsblk 
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sr0     11:0    1  558K  0 rom  
vda    252:0    0   10G  0 disk 
├─vda1 252:1    0    1M  0 part 
├─vda2 252:2    0  200M  0 part /boot/efi
├─vda3 252:3    0  500M  0 part /boot
└─vda4 252:4    0  9.3G  0 part /
vdb    252:16   0    5G  0 disk 
├─vdb1 252:17   0    1G  0 part 
└─vdb2 252:18   0    1G  0 part 
vdc    252:32   0    5G  0 disk 
vdd    252:48   0    5G  0 disk 


파일시스템 : 자료구조
파일과 디렉토리들을 저장 하기 위한 파일구조

파일시스템의 종류
---------------------------------------------------------------------------
ext2     (mkfs.ext2)     리눅스 이전 버전에서 사용하는 파일시스템
ext3     (mkfs.ext3)     현재 CentOS 5.X 사용하는 파일시스템
ext4     (mkfs.ext4)     CentOS 6.X 사용하는 파일시스템
xfs      (mkfs.xfs)      고성능 저널링 파일 시스템(eXtended File System)
msdos    mfs.msdos)      MS-DOS filesystem
---------------------------------------------------------------------------

VFS에 대한 추가
리눅스에서 파일의 개념은 파일을 바이트의 단순한 연속으로 간주한다. 리눅스는 모든 입출력 디바이스들을 파일로 취급하여 심지어 NIC, Disk, Keyborad, printer도 파일로 취급한다. 파일시스템은 모든 입출력을 제어하는 Device Driver와 연결되어 있고 시스템 호출을 통하여 사용자로부터 데이터를 받아 처리한다.

리눅스는 VFS(Virtual File System)을 통하여 ext2, jfs2, proc와 같은 다양한 파일시스템을 지원하고 있다.

가상 파일시스템 구조(Virtual File System)

VFS는 모든 파일 시스템이 필요로 하는 일련의 function을 정의하고 있다. 이러한 인터페이스는 세 종류 대상과 관련된 일련의 동작으로 구성된다. 즉 파일시스템, 아이노드, 열린 파일이다.

VFS는 커널에서 지원하는 파일시스템 타입을 알고 있다. 이는 커널 구성 동안에 만들어지는 테이블을 사용한다. 이 테이블 내의 각 엔트리가 하나의 파일 시스템 타입을 정의한다. 즉 파일시스템 타입의 이름과 function에 대한 포인터이다.

어떤 파일 시스템이 마운트 될 때 그에 맞는 마운트 function이 불러 들여진다. 이 function이 디스크의 슈퍼블록을 읽는 것을 담당하며, 내부 변수를 초기화하고 VFS에 마운트된 파일시스템 descriptor를 돌려준다.

파일시스템이 마운트 된 후에 VFS function은 물리적인 파일시스템 루틴을 접근하는데 이 descriptor를 사용한다. 마운트된 파일시스템 descriptor는 모든 파일시스템 타입에 공통된 몇 가지의 데이터를 포함 한다. 물리적 파일시스템 커널코드에 의해 제공되는 function에 대한 포인터와 물리적인 파일 시스템 코드에 필요한 고유정보이다. 파일시스템 descriptor에 포함된 function 포인터는 VFS가 파일 시스템 내부 루틴을 접근하는 것을 허용한다.

두 가지의 다른 descriptor가 VFS에 의해 사용된다. 아이노드 descriptor와 열린 파일 descriptor이다. 각 descriptor는 사용 중인 파일에 관련된 정보와 물리적인 파일시스템 코드에 의해 제공되는 일련의 동작을 갖고 있다. 아이노드 descriptor는 어떤 파일에 대해서도 사용되는 function에 대한 포인터를 포함하는데 비해 (e.g. create, unlink) 파일 descriptor는 열린 파일에 대해서만 작동하는 function에 대한 포인터를 갖는다. (e.g.read,write)

파일시스템 생성
mkfs
1 mkfs -t ext4
2 mkfs.ext4
mkfs.ext4 /dev/devicename_num

[root@servera ~]# lsblk /dev/vdb
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS
vdb    252:16   0   5G  0 disk 
├─vdb1 252:17   0   1G  0 part 
└─vdb2 252:18   0   1G  0 part 
파일시스템으로 생성 가능한 파티션은 두개
/dev/vdb1 ext4
/dev/vdb xfs

[root@servera ~]# mkfs.
mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.xfs
mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.vfat    





[root@servera ~]# mkfs.ext4 /dev/vdb1 
mke2fs 1.46.5 (30-Dec-2021)
Creating filesystem with 262144 4k blocks and 65536 inodes
Filesystem UUID: dd0d4df3-08d5-49e2-bf0b-07af71c7ea02
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

[root@servera ~]# mkfs.ext4 /dev/vdb1  기존의 FS을 버리고 새로 생성한다면 확인
mke2fs 1.46.5 (30-Dec-2021)
/dev/vdb1 contains a ext4 file system
        created on Wed Jul 24 14:28:29 2024
Proceed anyway? (y,N) y
Creating filesystem with 262144 4k blocks and 65536 inodes
Filesystem UUID: 177155e8-d4b6-4254-8322-be21915fcceb
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

[root@servera ~]# mkfs.xfs /dev/vdb2
meta-data=/dev/vdb2              isize=512    agcount=4, agsize=65536 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=0
         =                       reflink=1    bigtime=1 inobtcount=1
data     =                       bsize=4096   blocks=262144, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0

[root@servera ~]# mkfs.xfs /dev/vdb2
mkfs.xfs: /dev/vdb2 appears to contain an existing filesystem (xfs).
mkfs.xfs: Use the -f option to force overwrite.
[root@servera ~]# mkfs.xfs -f /dev/vdb2
meta-data=/dev/vdb2              isize=512    agcount=4, agsize=65536 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=0
         =                       reflink=1    bigtime=1 inobtcount=1
data     =                       bsize=4096   blocks=262144, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0

ext4 : 작은 파일들 저장에 장점
xfs   : 대용량 파일에 장점

[root@servera ~]# lsblk --fs /dev/vdb
NAME   FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
vdb                                                                           
├─vdb1 ext4   1.0         177155e8-d4b6-4254-8322-be21915fcceb                
└─vdb2 xfs                36241924-9a60-4afe-89b2-141fce559552                

파일 시스템을 사용하는 방법
자원 -  디스크라는 자원을 이용하는 방법
마운트를 통해서 디스크와 디렉토리를 연결 
컴퓨터에서 Mount란 어떠한 것을 Available 한 상태로 준비하는 것을 말한다.
좀 더 추상적인 개념이지, 딱 하나로 이어지는 구체적인 단어는 아니다.


마운트 ->
디스크-> 파티션 -> 파일시스템 —---[마운트]---------DIR
마운트 : 파일시스템을 이용하기 위하여 디렉토리와 연결해주는 작업

[root@servera ~]# mkdir /stage1
[root@servera ~]# df /stage1
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/vda4        9756652 3750536   6006116  39% /

마운트 명령을 사용하는 형식
# mount [파일시스템구성이완료된디스크] [마운트포인트,디렉토리]
 # mount [/dev/[PATH]] [마운트포인트,디렉토리]
# mount [UUID] [마운트포인트,디렉토리]

[root@servera ~]# mount /dev/vdb1 /stage1
[root@servera ~]# df /stage1
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/vdb1         996780    24    927944   1% /stage1

[root@servera ~]# cd /stage1/
[root@servera stage1]# ls
lost+found
[root@servera stage1]# touch file1
[root@servera stage1]# echo '/stage1 /dev/vdb1 mount' > info

[root@servera stage1]# cd   마운트 해제를 할때 자원에 접속해 있으면 umount가 불가능
umount : 마운트된 자원을 해제
[root@servera ~]# umount /stage1
[root@servera ~]# df 
Filesystem     1K-blocks    Used Available Use% Mounted on
devtmpfs          863980       0    863980   0% /dev
tmpfs             908696       0    908696   0% /dev/shm
tmpfs             363480    5140    358340   2% /run
/dev/vda4        9756652 3750536   6006116  39% /
/dev/vda3         506528  163796    342732  33% /boot
/dev/vda2         204580    7148    197432   4% /boot/efi
tmpfs             181736       0    181736   0% /run/user/1000
tmpfs             181736       0    181736   0% /run/user/0
[root@servera ~]# cd  /stage1
[root@servera stage1]# df .
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/vda4        9756652 3750536   6006116  39% /
df . 은 현재 디렉토리의 마운트 연결 정보를 확인
[root@servera stage1]# df /stage1
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/vda4        9756652 3750536   6006116  39% /
[root@servera stage1]# pwd
/stage1
[root@servera stage1]# ls
[root@servera stage1]#
umount 이후 확인된 데이터는 기존의 /dev/vdb1에 존재하던  info, file1이 없다.

신입 X 경력? X
확인안해서 나오는 실수.

마운트 방법 ..
1 전통적인 방법
# mount [device-name] [mountpoint]
2 UUID 작성 : 범용 고유 식별자

[root@servera ~]# lsblk --fs /dev/vdb1
NAME FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
vdb1 ext4   1.0         177155e8-d4b6-4254-8322-be21915fcceb                
UUID는 생성할 때 마다 다르기 때문에 본인의 머신을 확인 한뒤 복사 하시면 됩니다.
[root@servera ~]# mount UUID=177155e8-d4b6-4254-8322-be21915fcceb /stage1
[root@servera ~]# df  /stage1
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/vdb1         996780    28    927940   1% /stage1

권장 사항이 UUID인 이유:
임시 마운트에서는 뭘 사용하든 상관 없음.
하지만 fstab은 부팅시에 해당 파일을 보고 마운트 포인트 + 장치명을 연결
장치명으로 되어 있는 경우
vmware, 가상화 장치의 경우에는 scsi 어댑터, 채널 ID가 변경되면서 디스크의 이름이 변경되는 경우가 많음.
예시:
system disk : /dev/vda4
재부팅 -> 커널? 부팅 불가

UUID 가 아니라 장치명 자체로 사용을 하게 되면 
vda가 vdb, vdc가 될 수 있음. 부팅이 불가
UUID로 작성해두게 되면 장치명에 대한것을 systemd가 직접 구성하기에 부팅이 안되는 경우가 없으며 디스크데이터도 100% 마운트 가능

[root@servera ~]# mkdir /stage2
[root@servera ~]# mount /dev/vdb2 /stage2
[root@servera ~]# df 
Filesystem     1K-blocks    Used Available Use% Mounted on
devtmpfs          863980       0    863980   0% /dev
tmpfs             908696       0    908696   0% /dev/shm
tmpfs             363480    5140    358340   2% /run
/dev/vda4        9756652 3750556   6006096  39% /
/dev/vda3         506528  163796    342732  33% /boot
/dev/vda2         204580    7148    197432   4% /boot/efi
tmpfs             181736       0    181736   0% /run/user/1000
tmpfs             181736       0    181736   0% /run/user/0
/dev/vdb1         996780      28    927940   1% /stage1
/dev/vdb2        1038336   40292    998044   4% /stage2

UUID가 짧은 것도 있다.
GPT로 작업
[root@servera ~]# fdisk /dev/vdc

Welcome to fdisk (util-linux 2.37.4).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0x02d498e0.

Command (m for help): g
Created a new GPT disklabel (GUID: 848A7886-541A-4448-9ABA-774E143377C3).

Command (m for help): n
Partition number (1-128, default 1): 1
First sector (2048-10485726, default 2048): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-10485726, default 10485726): +1G

Created a new partition 1 of type 'Linux filesystem' and of size 1 GiB.

Command (m for help): 
Command (m for help): t
Selected partition 1
Partition type or alias (type L to list all): L
  1 EFI System                     C12A7328-F81F-11D2-BA4B-00A0C93EC93B
  2 MBR partition scheme           024DEE41-33E7-11D3-9D69-0008C781F39F
  3 Intel Fast Flash               D3BFE2DE-3DAF-11DF-BA40-E3A556D89593
  4 BIOS boot                      21686148-6449-6E6F-744E-656564454649
  5 Sony boot partition            F4019732-066E-4E12-8273-346C5641494F
  6 Lenovo boot partition          BFBFAFE7-A34F-448A-9A5B-6213EB736C22
  7 PowerPC PReP boot              9E1A2D38-C612-4316-AA26-8B49521E5A8B
  8 ONIE boot                      7412F7D5-A156-4B13-81DC-867174929325
  9 ONIE config                    D4E6E2CD-4469-46F3-B5CB-1BFF57AFC149
 10 Microsoft reserved             E3C9E316-0B5C-4DB8-817D-F92DF00215AE
 11 Microsoft basic data           EBD0A0A2-B9E5-4433-87C0-68B6B72699C7
 12 Microsoft LDM metadata         5808C8AA-7E8F-42E0-85D2-E1E90434CFB3
 13 Microsoft LDM data             AF9B60A0-1431-4F62-BC68-3311714A69AD
 14 Windows recovery environment   DE94BBA4-06D1-4D40-A16A-BFD50179D6AC
 15 IBM General Parallel Fs        37AFFC90-EF7D-4E96-91C3-2D7AE055B174
 16 Microsoft Storage Spaces       E75CAF8F-F680-4CEE-AFA3-B001E56EFC2D
 17 HP-UX data                     75894C1E-3AEB-11D3-B7C1-7B03A0000000
 18 HP-UX service                  E2A1E728-32E3-11D6-A682-7B03A0000000
 19 Linux swap                     0657FD6D-A4AB-43C4-84E5-0933C84B4F4F
 20 Linux filesystem               0FC63DAF-8483-4772-8E79-3D69D8477DE4
 21 Linux server data              3B8F8425-20E0-4F3B-907F-1A25A76F98E8
 22 Linux root (x86)               44479540-F297-41B2-9AF7-D131D5F0458A
 23 Linux root (x86-64)            4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709
 24 Linux root (ARM)               69DAD710-2CE4-4E3C-B16C-21A1D49ABED3
 25 Linux root (ARM-64)            B921B045-1DF0-41C3-AF44-4C6F280D3FAE
 26 Linux root (IA-64)             993D8D3D-F80E-4225-855A-9DAF8ED7EA97
 27 Linux reserved                 8DA63339-0007-60C0-C436-083AC8230908
 28 Linux home                     933AC7E1-2EB4-4F13-B844-0E14E2AEF915
 29 Linux RAID                     A19D880F-05FC-4D3B-A006-743F0F84911E
 30 Linux LVM                      E6D6D379-F507-44C2-A23C-238F2A3DF928
 31 Linux variable data            4D21B016-B534-45C2-A9FB-5C16E091FD2D
 32 Linux temporary data           7EC6F557-3BC5-4ACA-B293-16EF5DF639D1
 33 Linux /usr (x86)               75250D76-8CC6-458E-BD66-BD47CC81A812
 34 Linux /usr (x86-64)            8484680C-9521-48C6-9C11-B0720656F69E
 35 Linux /usr (ARM)               7D0359A3-02B3-4F0A-865C-654403E70625
 36 Linux /usr (ARM-64)            B0E01050-EE5F-4390-949A-9101B17104E9
 37 Linux /usr (IA-64)             4301D2A6-4E3B-4B2A-BB94-9E0B2C4225EA
 38 Linux root verity (x86)        D13C5D3B-B5D1-422A-B29F-9454FDC89D76
 39 Linux root verity (x86-64)     2C7357ED-EBD2-46D9-AEC1-23D437EC2BF5
 40 Linux root verity (ARM)        7386CDF2-203C-47A9-A498-F2ECCE45A2D6
 41 Linux root verity (ARM-64)     DF3300CE-D69F-4C92-978C-9BFB0F38D820
 42 Linux root verity (IA-64)      86ED10D5-B607-45BB-8957-D350F23D0571
 43 Linux /usr verity (x86)        8F461B0D-14EE-4E81-9AA9-049B6FB97ABD
 44 Linux /usr verity (x86-64)     77FF5F63-E7B6-4633-ACF4-1565B864C0E6
 45 Linux /usr verity (ARM)        C215D751-7BCD-4649-BE90-6627490A4C05
 46 Linux /usr verity (ARM-64)     6E11A4E7-FBCA-4DED-B9E9-E1A512BB664E
 47 Linux /usr verity (IA-64)      6A491E03-3BE7-4545-8E38-83320E0EA880
 48 Linux extended boot            BC13C2FF-59E6-4262-A352-B275FD6F7172
 49 Linux user's home              773f91ef-66d4-49b5-bd83-d683bf40ad16
 50 FreeBSD data                   516E7CB4-6ECF-11D6-8FF8-00022D09712B
 51 FreeBSD boot                   83BD6B9D-7F41-11DC-BE0B-001560B84F0F
 52 FreeBSD swap                   516E7CB5-6ECF-11D6-8FF8-00022D09712B
 53 FreeBSD UFS                    516E7CB6-6ECF-11D6-8FF8-00022D09712B
 54 FreeBSD ZFS                    516E7CBA-6ECF-11D6-8FF8-00022D09712B
 55 FreeBSD Vinum                  516E7CB8-6ECF-11D6-8FF8-00022D09712B
 56 Apple HFS/HFS+                 48465300-0000-11AA-AA11-00306543ECAC
 57 Apple APFS                     7C3457EF-0000-11AA-AA11-00306543ECAC
 58 Apple UFS                      55465300-0000-11AA-AA11-00306543ECAC
 59 Apple RAID                     52414944-0000-11AA-AA11-00306543ECAC
 60 Apple RAID offline             52414944-5F4F-11AA-AA11-00306543ECAC
 61 Apple boot                     426F6F74-0000-11AA-AA11-00306543ECAC
 62 Apple label                    4C616265-6C00-11AA-AA11-00306543ECAC
 63 Apple TV recovery              5265636F-7665-11AA-AA11-00306543ECAC
 64 Apple Core storage             53746F72-6167-11AA-AA11-00306543ECAC
 65 Solaris boot                   6A82CB45-1DD2-11B2-99A6-080020736631
 66 Solaris root                   6A85CF4D-1DD2-11B2-99A6-080020736631
 67 Solaris /usr & Apple ZFS       6A898CC3-1DD2-11B2-99A6-080020736631
 68 Solaris swap                   6A87C46F-1DD2-11B2-99A6-080020736631
 69 Solaris backup                 6A8B642B-1DD2-11B2-99A6-080020736631
 70 Solaris /var                   6A8EF2E9-1DD2-11B2-99A6-080020736631
 71 Solaris /home                  6A90BA39-1DD2-11B2-99A6-080020736631
 72 Solaris alternate sector       6A9283A5-1DD2-11B2-99A6-080020736631
 73 Solaris reserved 1             6A945A3B-1DD2-11B2-99A6-080020736631
 74 Solaris reserved 2             6A9630D1-1DD2-11B2-99A6-080020736631
 75 Solaris reserved 3             6A980767-1DD2-11B2-99A6-080020736631
 76 Solaris reserved 4             6A96237F-1DD2-11B2-99A6-080020736631
 77 Solaris reserved 5             6A8D2AC7-1DD2-11B2-99A6-080020736631
 78 NetBSD swap                    49F48D32-B10E-11DC-B99B-0019D1879648
 79 NetBSD FFS                     49F48D5A-B10E-11DC-B99B-0019D1879648
 80 NetBSD LFS                     49F48D82-B10E-11DC-B99B-0019D1879648
 81 NetBSD concatenated            2DB519C4-B10E-11DC-B99B-0019D1879648
 82 NetBSD encrypted               2DB519EC-B10E-11DC-B99B-0019D1879648
 83 NetBSD RAID                    49F48DAA-B10E-11DC-B99B-0019D1879648
 84 ChromeOS kernel                FE3A2A5D-4F32-41A7-B725-ACCC3285A309
 85 ChromeOS root fs               3CB8E202-3B7E-47DD-8A3C-7FF2A13CFCEC
 86 ChromeOS reserved              2E0A753D-9E48-43B0-8337-B15192CB1B5E
 87 MidnightBSD data               85D5E45A-237C-11E1-B4B3-E89A8F7FC3A7
 88 MidnightBSD boot               85D5E45E-237C-11E1-B4B3-E89A8F7FC3A7
 89 MidnightBSD swap               85D5E45B-237C-11E1-B4B3-E89A8F7FC3A7
 90 MidnightBSD UFS                0394EF8B-237E-11E1-B4B3-E89A8F7FC3A7
 91 MidnightBSD ZFS                85D5E45D-237C-11E1-B4B3-E89A8F7FC3A7
 92 MidnightBSD Vinum              85D5E45C-237C-11E1-B4B3-E89A8F7FC3A7
 93 Ceph Journal                   45B0969E-9B03-4F30-B4C6-B4B80CEFF106
 94 Ceph Encrypted Journal         45B0969E-9B03-4F30-B4C6-5EC00CEFF106
 95 Ceph OSD                       4FBD7E29-9D25-41B8-AFD0-062C0CEFF05D
 96 Ceph crypt OSD                 4FBD7E29-9D25-41B8-AFD0-5EC00CEFF05D
 97 Ceph disk in creation          89C57F98-2FE5-4DC0-89C1-F3AD0CEFF2BE
 98 Ceph crypt disk in creation    89C57F98-2FE5-4DC0-89C1-5EC00CEFF2BE
 99 VMware VMFS                    AA31E02A-400F-11DB-9590-000C2911D1B8
100 VMware Diagnostic              9D275380-40AD-11DB-BF97-000C2911D1B8
101 VMware Virtual SAN             381CFCCC-7288-11E0-92EE-000C2911D0B2
102 VMware Virsto                  77719A0C-A4A0-11E3-A47E-000C29745A24
103 VMware Reserved                9198EFFC-31C0-11DB-8F78-000C2911D1B8
104 OpenBSD data                   824CC7A0-36A8-11E3-890A-952519AD3F61
105 QNX6 file system               CEF5A9AD-73BC-4601-89F3-CDEEEEE321A1
106 Plan 9 partition               C91818F9-8025-47AF-89D2-F030D7000C2C
107 HiFive Unleashed FSBL          5B193300-FC78-40CD-8002-E86C45580B47
108 HiFive Unleashed BBL           2E54B353-1271-4842-806F-E436D6AF6985

Aliases:
   linux          - 0FC63DAF-8483-4772-8E79-3D69D8477DE4
   swap           - 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F
   home           - 933AC7E1-2EB4-4F13-B844-0E14E2AEF915
   uefi           - C12A7328-F81F-11D2-BA4B-00A0C93EC93B
   raid           - A19D880F-05FC-4D3B-A006-743F0F84911E
   lvm            - E6D6D379-F507-44C2-A23C-238F2A3DF928
q
Partition type or alias (type L to list all): 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F
Changed type of partition 'Linux filesystem' to 'Linux swap'.

Command (m for help): t
Selected partition 1
Partition type or alias (type L to list all): swap
Changed type of partition 'Linux swap' to 'Linux swap'.

Command (m for help): t
Selected partition 1
Partition type or alias (type L to list all): linux
Changed type of partition 'Linux swap' to 'Linux filesystem'.

Command (m for help): 
Command (m for help): p
Disk /dev/vdc: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 848A7886-541A-4448-9ABA-774E143377C3

Device     Start     End Sectors Size Type
/dev/vdc1   2048 2099199 2097152   1G Linux filesystem

Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.

[root@servera ~]# 

[root@servera ~]# mkfs.vfat /dev/vdc1
mkfs.fat 4.2 (2021-01-31)
[root@servera ~]# lsblk --fs /dev/vdc1
NAME FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
vdc1 vfat   FAT32       D833-2F43         

위에서 작성한 마운트의 경우에는 임시 마운트

사용중인 파일 시스템 마운트 해제
[root@servera stage1]# pwd
/stage1
[root@servera stage1]# umount /stage1
umount: /stage1: target is busy.
[root@servera stage1]# df /stage1
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/vdb1         996780    28    927940   1% /stage1
[root@servera stage1]# cd 
[root@servera ~]# umount /stage1
[root@servera ~]# df /stage1
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/vda4        9756652 3750536   6006116  39% /
본인 계정이 접속된 상황이었기 때문에 다른곳으로 이동만 하면 그만

[student@servera stage2]$ df .
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/vdb2        1038336 40292    998044   4% /stage2
타 계정으로 /stage2 에 접근
[root@servera ~]# who
root     pts/0        2024-07-24 10:00 (172.25.250.9)
student  pts/1        2024-07-23 17:25 (172.25.250.9)
student  pts/2        2024-07-24 15:25 (172.25.250.9)
하지만 접근 계정이 몇십 몇백?
[root@servera ~]# fuser -cu /stage2
/stage2:             30205c(student)
30205c   -> PID
[root@servera ~]# ps -ef | grep 30205
student    30205   30204  0 15:25 pts/2    00:00:00 -bash
root       30235   29767  0 15:27 pts/0    00:00:00 grep --color=auto 30205

[root@servera ~]# fuser -ck /stage2
/stage2:             30205c
[root@servera ~]# umount /stage2

minimal 버전에서는 설치가 되어 있지 않음
# dnf - y install psmisc

위에서 작성한 마운트의 경우에는 임시 마운트
영구마운트?

1 /etc/fstab
2 사용할 자원
/dev/vdb1 vdb2

[root@servera ~]# vi /etc/fstab
shift + g > o 

defaults        0       0
fstab 형식
/dev/vdb1            /stage1             ext4    defaults        0       0
device,UUID       mountpoint         fs       option          dump fsck 

dump 0 1 
fsck 0 1 2
0 사용하지 않음
1 fsck 사용 : / 
2 fsck 사용 : /를 제외한 경우
fsck  -> ext 계열
xfs 는 자동으로 다른 명령을 사용하기 때문에 0으로 처리

UUID=
esc > :!lsblk –fs
내용을 복사
enter
vi로 복귀 > shift + A 
붙여넣기

1 /dev/vdb1            /stage1             ext4    defaults        0       0
2 UUID=36241924-9a60-4afe-89b2-141fce559552       /stage2 xfs     defaults        0       0
권장 사항: UUID를 사용하는것을 권장
esc
:wq

[root@servera ~]# systemctl daemon-reload  : systemd가 변경 된 사항을 업데이트
[root@servera ~]# mount -a : fstab 파일에서 마운트 가능한 모든 자원을 마운트 * 
[root@servera ~]# df 
Filesystem     1K-blocks    Used Available Use% Mounted on
devtmpfs          863980       0    863980   0% /dev
tmpfs             908696       0    908696   0% /dev/shm
tmpfs             363480    5152    358328   2% /run
/dev/vda4        9756652 3750556   6006096  39% /
/dev/vda3         506528  163796    342732  33% /boot
/dev/vda2         204580    7148    197432   4% /boot/efi
tmpfs             181736       0    181736   0% /run/user/1000
tmpfs             181736       0    181736   0% /run/user/0
/dev/vdb1         996780      28    927940   1% /stage1
/dev/vdb2        1038336   40292    998044   4% /stage2

부팅 전에 꼭 마운트를 해보는것이 좋다!

[root@servera ~]# mount /stage2
fstab에 자원이 등록되어 있다면 마운트 포인트만 작성하여도 마운트가 가능

자원등록이 정상적이지 않다면 부팅이 되지 않는다.

부팅불가 상태가 되면
fstab에서 생기는 문제
1 fstab에서 추가한 자원들을 먼저 주석처리하고 부팅
2 확인 뒤 수정 후 부팅

serverb에서 작업
227페이지
랩명령은 입력하지 마시고 serverb에서 작성

[231]
swap

가상메모리
사용이유 : 물리 메모리가 부족한 경우 메모리를 대체하기 위하여 2차 저장장치인 디스크를 사용하여 메모리의 데이터를 대체

RAM 및 스왑 공간 권장 사항
4GB

스왑공간을 사용하게 되는 이유
1 물리 메모리가 부족한 경우
2 프로그램 개발시 swap을 이용하도록 개발자가 정의한 경우

1번의 경우 스왑공간을 메모리처럼 이용하다보니 생기는 단점

느려짐
디스크의 특정 공간, 파티션 점유

스왑은 사용을 해야 하는 경우가 아니라면 빠르게 물리 메모리 증설
프로그램을 분산

스왑을 생성하는 두가지 방법
1 파티션 형태 * 시험에서는 이 방법을 사용해야 한다
2  파일

[root@servera ~]# fdisk /dev/vdb

Welcome to fdisk (util-linux 2.37.4).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

This disk is currently in use - repartitioning is probably a bad idea.
It's recommended to umount all file systems, and swapoff all swap
partitions on this disk.
현재 사용중인 디스크이기 때문에 경고 메시지를 한번 뿌림

Command (m for help): n
Partition type
   p   primary (2 primary, 0 extended, 2 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (3,4, default 3): 
First sector (4196352-10485759, default 4196352): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (4196352-10485759, default 10485759): +1G

Created a new partition 3 of type 'Linux' and of size 1 GiB.

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start     End Sectors Size Id Type
/dev/vdb1          2048 2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 4196351 2097152   1G 83 Linux
/dev/vdb3       4196352 6293503 2097152   1G 83 Linux

Command (m for help): t
Partition number (1-3, default 3): 3
Hex code or alias (type L to list all): 82

Changed type of partition 'Linux' to 'Linux swap / Solaris'.

Command (m for help): p
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d3647ea

Device     Boot   Start     End Sectors Size Id Type
/dev/vdb1          2048 2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 4196351 2097152   1G 83 Linux
/dev/vdb3       4196352 6293503 2097152   1G 82 Linux swap / Solar

Command (m for help): w
The partition table has been altered.
Syncing disks.

파티션 준비는 종료
[root@servera ~]# lsblk --fs /dev/vdb
NAME FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
vdb                                                                         
├─vdb1
│    ext4   1.0         177155e8-d4b6-4254-8322-be21915fcceb  906.2M     0% /stage1
├─vdb2
│    xfs                36241924-9a60-4afe-89b2-141fce559552  974.7M     4% /stage2
└─vdb3

[root@servera ~]# mkswap /dev/vdb3
Setting up swapspace version 1, size = 1024 MiB (1073737728 bytes)
no label, UUID=81f211ee-cadb-4d77-b774-54108e8001df

[root@servera ~]# lsblk --fs /dev/vdb
NAME FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
vdb                                                                         
├─vdb1
│    ext4   1.0         177155e8-d4b6-4254-8322-be21915fcceb  906.2M     0% /stage1
├─vdb2
│    xfs                36241924-9a60-4afe-89b2-141fce559552  974.7M     4% /stage2
└─vdb3
     swap   1           81f211ee-cadb-4d77-b774-54108e8001df    
swap의 UUID도 블록 디바이스라면 저장하고 있기 때문에 따로 저장하지 않아도 된다.

스왑 활성화
[root@servera ~]# swapon /dev/vdb3

활성화된 스왑 확인
[root@servera ~]# swapon -s
Filename                                Type            Size            Used            Priority
/dev/vdb3                               partition       1048572         0               -2

[root@servera ~]# swapoff /dev/vdb3
[root@servera ~]# swapon -s
[root@servera ~]# 


파일로 생성하는 스왑
임시로 잠깐 사용하고 버리는 용도

[root@servera ~]# mkdir /swap
[root@servera ~]# cd /swap/
[root@servera swap]# dd if=/dev/zero of=swapfile bs=1M count=1024
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 1.62763 s, 660 MB/s
[root@servera swap]# mkswap swapfile 
mkswap: swapfile: insecure permissions 0644, fix with: chmod 0600 swapfile
Setting up swapspace version 1, size = 1024 MiB (1073737728 bytes)
no label, UUID=96e7d89b-17cd-419a-9e03-1d90fa489d93
권한을 변경하라 0600로 변경
[root@servera swap]# chmod 0644 swapfile 

[root@servera swap]# chmod 0600 swapfile 
[root@servera swap]# swapon /swap/swapfile
[root@servera swap]# swapon -s
Filename                                Type            Size            Used            Priority
/swap/swapfile                          file            1048572         0               -2

[root@servera swap]# swapon /dev/vdb3
[root@servera swap]# swapon -s
Filename                                Type            Size            Used            Priority
/swap/swapfile                          file            1048572         0               -2
/dev/vdb3                               partition       1048572         0               -3

Priority : 우선순위 스왑을 이용할때 빠른 디스크 먼저 사용할 수 있도록 숫자를 변경
swapon 명령에서는 -p 옵션
fstab에서는 옵션에서 pri=   32767까지 사용 가능하며 정수로 높은 숫자가 우선순위를 가진다.

[root@servera swap]# swapoff /dev/vdb3
[root@servera swap]# swapon -p 10 /dev/vdb3
[root@servera swap]# swapon -s
Filename                                Type            Size            Used            Priority
/swap/swapfile                          file            1048572         0               -2
/dev/vdb3                               partition       1048572         0               10

fstab을 이용하여 등록
[root@servera swap]# swapoff /swap/swapfile
[root@servera swap]# swapoff /dev/vdb3

[root@servera swap]# vi /etc/fstab
UUID=81f211ee-cadb-4d77-b774-54108e8001df       swap    swap    pri=10        0       0
/swap/swapfile  swap swap       defaults        0       0
[root@servera swap]# systemctl daemon-reload 
[root@servera swap]# swapon -a
fstab에 존재하는 swap들을 한번에 활성화 시키는 옵션 
[root@servera swap]# swapon -s
Filename                                Type            Size            Used            Priority
/dev/vdb3                               partition       1048572         0               10
/swap/swapfile                          file            1048572         0               -2
[root@servera swap]# swapoff -a
[root@servera swap]# swapon -s
[root@servera swap]# 

디스크 초기화 및 나머지 정리
H/W > 파티션 생성 > 파일시스템 > 마운트 > fstab
fstab 삭제 > umount > 디스크 초기화
[root@servera ~]# vi /etc/fstab
기존에 생성한 내용들을 삭제
# umount /stage1
# umount /stage2
# swapoff /dev/vdb3
# swapoff /swap/swapfile
[root@servera ~]# dd if=/dev/zero of=/dev/vdb

[239] 랩을 실행 3,4 
[235] 전체 
둘중에 하나 선택
17:20분
LVM  개념정리만 하고 끝

표준파티션의 가장 큰 단점:
파티션을 한번 생성하고 나면 용량 변경이 힘들다.

LVM : 용량에 대한 조절이 쉽다.
클라우드에서도 보통 LVM 체계를 많이 사용하고 있기 때문에 나중을 위해서라도 섹션은 잘 기억해 두시기 바랍니다.

LVM
  LVM(Logical Volume Manage)이란?

(Virtual Volume Technology)  - LVM(Logical Volume Manager), RAID(Redudant Array Inexpensive Disk) 

 가상 볼륨 방식 장점: (ㄱ) 확장성, (ㄴ) 안정성, (ㄷ) 편의성(관리 용이) 

 (권장)  OS(Operating System) - LVM 기술 사용 권장

DATA 공간 - Storage(Hardware RAID)

물리적인 디스크를 논리적 볼륨그룹으로 구성해서 이 논리적인 볼륨그룹 내에 사용자가 원하는 크기 만큼의 논리볼륨을 할당하여 사용하는 방법으로, 

여러 개의 디스크를 하나의 논리적인 볼륨그룹(VG)으로 구성할 수 있으며, 

각 논리볼륨(LV)는 독립적이므로, 하나의 디스크에도 여러 가지의 파일 시스템을 설치할 수 있다. 

또한 디스크의 용량증설이 요구 될 경우에도 볼륨그룹에 물리볼륨(PV)만 추가하여 용량증설이 가능하고, 
데이터량이 감소하여 더 이상 많은 양의 저장공간이 필요 없는 경우, 볼륨그룹에 속한 물리볼륨 개수를 축소하여 용량 감소가 가능하다.

LVM은 PV(Physical Volume), VG(Volume Group), LV(Logical Volume)으로 구성된다
구성요소                      설명
Physical Volume             PV는 하나의 물리적인 Disk에 LVM을 사용할 수 있도록 LVM 데이터 구조를 생성한 것을 말한다. 
                            디스크에 PV가 생성되면 LVM은 디스크를 하나의 물리볼륨으로 간주하게 되고, 볼륨그룹에 포함시킬 수 있게 된다.
                            따라서 하나의 디스크를 몇 개의 섹션은 논리볼륨으로, 몇 개의 섹션은 전체디스크로 관리하는 등의 방법은 적용 할 수 없다.
			    (예) 물리적인 디스크(EX:/dev/sda) or 물리적인 파티션(EX:/dev/sda1)

Volume Group                VG는 하나 또는 그 이상의 PV를 포함하며, LV를 생성할 수 있는 Volume Group의 집합이다. 
			    vg00은 부팅정보와 OS가 있는 root Volume Group으로 변경이 불가능하다.
			    관리자가 관리상의 편의를 위해 DB의 경우에는 vgdb##, 일반적인 파일시스템의 경우에는vgfil##등으로 VG이름을 지정하여 사용한다.
			    (예) 가상 디스크

Logical Volume              LV는 하나 또는 그 이상의 PV로 구성되어 있는 VG 공간을 전체 또는 분할하여 일반 파일시스템, swap or dump area,
			    raw disk로 사용할 수 있도록 논리적으로 할당한공간이다. 
			    운영 중 공간이 부족할 경우 볼륨그룹에 속해 있는 또 다른 물리볼륨을 사용하여 확장이 가능하고, 필요하다면 크기를 변경하거나 다른 디스크로 데이터를 옮길 수 있다. 
			    Volume Group vg00에 속한 Logical Volume lvol1,lvol2,lvol3은 각각 /stand, primary swap, / 디렉토리로 변경이 불가능 하다.
			    (예) 가상 파티션

LVM 작동방식
 PE (Physical Extent)  : PV가 갖는 일정한 블록

디스크에 PV를 생성하게 되면, LVM은 주소를 지정할 수 있는 PE(Physical Extent)라는 단위로 각 물리 디스크를 나눈다. extent는 주소 0번부터 시작하여 1씩 증분하며 순차적으로 디스크에 할당되고, PE의 크기는 볼륨 그룹을 만들 때 구성할 수 있다. 그리고 각 PE의 크기는 default 값이 4MB이며, 이 값은 필요에 따라 볼륨 그룹을 생성 시 1MB에서 256MB 사이의 값으로 지정할 수 있다.

 LE (Logical Extent)  : LV가 갖는 일정한 블록

디스크에 PV를 생성하고, 생성된 PV를 이용하여 VG(Volume Group)을 구성한 후 이 VG에 LV(Logical Volume)를 생성할 수 있다. LV의 기본 할당 단위를 LE(Logical Extent)라고 하는데, 이 LE는 PV 생성 시 나누어진 PE 영역과 Mapping된다. 따라서 PE의 크기가 4MB이면 LE의 크기도 4MB가 된다. 그리고 LV의 크기는 구성된 LE의 개수 또는 할당할 디스크 용량에 의해 결정된다.

VG에서 PE 사이즈를 결정하고 나면  LE는 매핑되어 있는 상태기 때문에 용량을 다시 변경 할 수 없다.

LVM과 Data Access

앞서 말한 바와 같이 LVM이 논리볼륨에 디스크 공간을 할당할 때 LVM은 주소 0에서 시작하여 각 디스크에 순차적으로 할당된 PE와 할당된 LE의 Mapping Table을 만든다. 따라서 LVM은 그림 9.3과 같이 실제 데이터가 물리 볼륨에 상주하는 위치와 상관없이 논리 볼륨을 Access 함으로써 데이터에 액세스 한다.

LVM과 root 파티션

논리 볼륨이 루트, 부팅, 기본 스왑 또는 덤프에 사용될 경우에는 PE영역은 연속적이어야 한다. 즉, 단일 물리 볼륨에 공백 없이 PE를 할당해야한다. 그러나 루트가 아닌 디스크의 논리 볼륨의 LE에 대응되는 PE는 물리 볼륨에서 연속적이지 않거나 전혀 다른 디스크에 상주할 수 있다. 결과적으로 한 논리 볼륨에 속한 파일 시스템이 둘 이상의 디스크에 상주할 수 있다.

fstab lvm으로 정상 데이터 저장이 되는가?

시험에서도 LVM 생성 -> 재부팅이후에도 자동 마운트 되는지까지





















































