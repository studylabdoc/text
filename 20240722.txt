깃허브
https://github.com/studylabdoc/text/blob/main/20240722.txt

구글드라이브
https://drive.google.com/drive/folders/1MIP3LQNU3oISKebgHWvUCgEVF4_2Xg95?usp=sharing

miro
https://miro.com/app/board/uXjVKwkVIgM=/?share_link_id=305482122361

google docs
https://docs.google.com/document/d/1vbzX5a2MGcT2SaKxQ3SR5XfKiK7ITvymUA98Fyz7eUI/edit?usp=sharing

[랩 접속 방법]
메일 : 20240722
rol.redhat.com  < RHLS 

MY VIRTUAL TRAINING CLASSES
RH134 - Red Hat System Administration II
Class Starts: 월, 7월 22 2024, 10:00 오전 

Class Ends: 금, 7월 26 2024, 06:00 오후 
JOIN

리소스 -> pdf download
랩 > workstation
Web Applications>  Classroom Web Terminal > access

PDF는 MS 엣지로 오픈
10:00 - 18:00 
쉬는시간 : 10 / 15분 
점심시간 : 12:30 - 14:00

[10] < 10page 

[7]
목차

RH134 과정을 위한 사전 명령어
# ls
디렉토리의 컨켄츠 확인
# chmod
권한 변경
# pwd
현재 디렉토리 확인
# passwd
비밀번호 변경
# useradd
계정 생성
# rm
삭제
# cp
복사
# mv
파일 이동 / 이름 변경
# date
시간 확인 / 시간변경 > timedatectl
# touch
파일의 시간 변경 , 빈 파일 생성
# mkdir
디렉토리 생성
# rmdir
빈 디렉토리 삭제 -> rm -rf dir
# id
현재 계정의 정보 확인
UID / GID / groups / selinux data
# cat
파일 확인 / 파일 병합 > 표준 출력 
# tac
파일 출력 방향을 반대로 돌림
# ps
프로세스 확인 / ps / ps -ef / ps aux
# bash
사용자 쉘 명령 / 서브 쉘을 실행 최근에는 bash도 사용하지만 fish / zsh 도 많이 사용중
# su -
접속 된 계정이 아닌 새로운 계정으로 전환 / 최근에는 sudo 명령 권장
# echo
빈 한 줄을 리턴 / 환경변수 호출
# more
cat의 경우에는 라인이 길어도 모두 한번에 출력
페이지 단위로 한 페이지 씩 끊어서 화면에 출력
more와 man에서 사용되는 기능키
* spacebar : 매뉴얼 페이지에서 한 화면 단위로 넘어 갈 때 사용
Enter : 매뉴얼 페이지에서 한 라인씩 넘어 갈 때 사용
b : Back Screen, 한 화면 전 화면으로 넘어갈 때 사용
* /pattern : 특정한 패턴을 빨리 찾을 때 사용
* n : Next, 특정한 패턴을 찾은 후 다음 번째 똑같은 문자열을 찾을 때 사용
h : help 매뉴얼 페이지 안에서 사용 할 수 있는 명령어 소개
* q : quit, 빠져나옴
# man
도움말 
https://linux.die.net/man/
# clear
화면을 청소 / 청소 이후 위의 출력 결과를 알수가 없음
# ln
출력 결과의 앞에 번호를 붙임
# tree
파일시스템의 파일, 디렉토리의 구조화
# dnf
yum, dnf 패키지 관리 프로그램
# chown
소유자 변경 
# umask
기본 권한 변경, 확인
# which
명령어 절대경로 확인
# whereis
매뉴얼 확인
# alias
기본 명령이 아닌 쉽게 사용할 수 있는 약어 생성, 확인
# histroy
사용한 명령어를 확인
# stat
전체 시간 정보 + 권한등 여러가지를 확인
# file
파일의 형식 확인
# cat file1 file2 > file3
표준 출력의 리다이렉션
# find . -name core 2> /dev/null
표준 에러의 리다이렉션
# cat < file1
표준 입력의 리다이렉션
# ssh
원격 접속을 위한 보안 쉘
# scp
원격 파일 복사를 위한 보안 쉘 [사용을 현재 중지]
# sftp
보안 파일 전송 프로토콜
# script
화면에 출력되는 모든 텍스트를 캡처, 저장
# vi
텍스트 에디터
# systemctl
systemd를 위한 명령어
# exit
쉘을 빠져나가기
# export
환경 변수 지정
# ^c
현재 작업중인 내용을 인터럽트하고 강제 종료
# ^d
EOF / EXIT
EOF: 파일의 끝
EXIT: 쉘을 끝내는 단축키
# poweroff
시스템 종료
# reboot
재부팅
# shutdown
시스템 종료 / 유예시간을 부여 할 수 있다. 
# ping
ICMP 프로토콜을 이용하여 헬스 체크 / 조건문에서 사용하기 위해 작성
# ifconfig
NIC 정보 확인 > 최근에는 잘 사용되지 않음.
net-tools 패키지가 있어야 하지만 설치자체를 하지 않음.
ip a 명령으로 대체
# head
파일의 상단 10줄
# tail
파일의 하단 10줄
# who
현재 접속자 확인
# last
사용자들의 접속 기록
# lastb
사용자의 잘못된 접속 기록
# w
현재 접속자의 사용 명령 확인
# while true do ; action ; done
반복문
# df
디스크의 남은 용량 / 파일 시스템 확인
# du
디스크의 사용 용량
# sort
데이터 정렬
# uniq 
데이터의 값 중 유일한 것 하나만 추출
# tee
출력을 두 방향으로 복제
# screen
지금은 tmux 명령으로 변경
쉘을 이용하면 쉘이 꺼지게 되면 작업 중지
내부에서 백 그라운드 작업으로 돌기 때문에 쉘이 꺼져도 계속 작업이 가능.
# mail
s-nail 명령으로 변환
# wall 
현재 실행중인 모든 터미널에 동일한 내용으로 브로드캐스트 
# grep
컨텐츠 내에서 특정 패턴을 찾기 위해 사용
+ 특정 패턴을 걸고 디렉토리나 파일에서 해당 내용이 존재하는 파일을 찾는 용도
# find
inode 정보를 필터링 하여 원하는 파일 / 디렉토리를 찾는 용도
+ 검색된 파일과 디렉토리에 실행 명령을 내려 2차 작업이 가능 

124 / 134 / 199 -> RHCSA

시험을 대비하는 분들을 위해:
1장
연습가이드: 간단한 Bash 스크립트 작성
2장
연습가이드: 반복 실행 사용자 작업 예약
3장
연습가이드: 정확한 시간 유지 관리
4장
연습 가이드: 압축된 tar 아카이브 관리 
tar + gz , bzip2, xz 
5장
연습가이드: 튜닝 프로파일 조정
6장
연습 가이드: SELinux 문제 조사 및 해결
+ 11장 연습 가이드: SELinux 포트 레이블 지정 제어
+ 연습 가이드: 서버 방화벽 관리

7장 8장 all
block storage를 마운트 하고 fstab까지 구성이 가능한 상태 >
LVM 구성 
+ LVM 생성
+ LVM 확장
+ swap

9장
연습 가이드: 네트워크 연결 스토리지 자동 마운트

10장
연습 가이드: 루트 암호 재설정

13장
container build 
container image control
연습 가이드: 컨테이너를 시스템 서비스로 관리

[14]
강의실 환경에 대한 오리엔테이션
workstation : 작업을 위한 컴퓨터
servera,serverb : 실제 작업을 위한 서버 
나머지 서버들은 lab 환경을 위해 존재한다.

시스템의 계정들은 다음과 같다.
student / student
root / redhat

1장
[20]
스크립트 = 자동화
쉘 스크립트, perl, -> [ansible:RHCE:RH294]

스크립트 top-down 
리눅스에 존재하는 왠만한 파일들은 위에서 아래로 읽어 내려감
1 shell을 사용한다는 것을 명시
2 명령어 작성

# vi run.sh
리눅스에서는 파일명 끝의 확장자는 아무 의미 없음.

명령 인터프리터 지정
# < 주석 처리로 진행이 되지만 첫줄에서 #! -> 이 뒤에 오는 파일 명을 가지고 쉘을 실행
sample
#!/usr/bin/bash == #!/bin/bash

실제 사용할 명령 리스트 순서대로 진행

date
echo 'run.sh file'
sleep 2
echo 'run.sh exit'


$ vi run.sh
---------------------------
#!/usr/bin/bash
date
echo 'run.sh file'
sleep 2
echo 'run.sh exit'
---------------------------

i : 입력모드
입력
esc -> 명령행모드
:wq  -> 저장+ 빠져나가기

현재 쉘에서 실행하기
./run.sh
./ = 현재 디렉토리 
run.sh = 실제 사용할 파일
./= /home/student/
./run.sh = /home/student/run.sh
실행을 위해서는 x권한이 필요
[student@workstation ~]$ ls -l run.sh
-rw-r--r--. 1 student student 67 Jul 21 23:12 run.sh
[student@workstation ~]$ chmod u+x run.sh
[student@workstation ~]$ ls -l run.sh
-rwxr--r--. 1 student student 67 Jul 21 23:12 run.sh

명령어를 호출하는 순서
1 hash에서 검색 
  # hash , # hash -r 
2 alias 에서 확인
3 실제 경로를 확인
4 명령어 실행

# command ls
alias 무시후 실제 경로에서만 실행

[student@workstation ~]$ echo $PATH
/home/student/.local/bin:/home/student/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/home/student/.venv/labs/bin
PATH 환경변수는 명령어를 입력 했을때 3번[실제 경로를 확인] 작업을 위한 디렉토리를 모아둔 곳

실제 경로를 확인
[student@workstation ~]$ ls
Desktop    Downloads  Music     Public  Templates
Documents  file1      Pictures  run.sh  Videos
[student@workstation ~]$ mkdir bin
[student@workstation ~]$ mv run.sh bin
[student@workstation ~]$ tree bin
bin
└── run.sh

0 directories, 1 file
run.sh 파일을 bin 디렉토리 아래에 복사.
해당 디렉토리는 /home/student/bin에 존재

0 directories, 1 file
run.sh 파일을 bin 디렉토리 아래에 복사.
해당 디렉토리는 /home/student/bin에 존재

인용 특수 문자 -> 메타캐릭터
shell에서 특수문자를 파일명에 추가 하지 마라.
!@#$%^&*()_ | ‘ “ ; : , . / \ ~ `  -> 쉘에서 하는 기능들이 있다.
명령어 입력 -> 
# ls -l $(which ls)
> 토큰 단위로 분할 [빈칸 ]
1  ls
2  -l
3  $(which ls)
쉘에서는 특수문자를 기능으로 사용을 한다.
파일을 생성 할때:
255 자.
빈칸 쓰지말고
특수문자 쓰지말고
영문자, 대문자, 숫자, -, _ , . 만 가지고 생성
자주 사용되는 메타캐릭터:
# : 주석 처리
\:
1 바로 뒤에 오는 한가지 문자를 해석하지 않음
[student@workstation ~]$ echo \$HOME
$HOME
2 명령어 라인의 끝에 \를 붙이게 되면 PS2 변수를 반환 하면서 라인을 끝내지 않고 아래줄에서 이어서 작성
‘ : ‘text’따옴표 안의 문자열을 해석하지 않음
“: “text”따옴표 안의 문자열을 해석하지 않음 [하지만 해석하는 문자도 있다. \ ` $]
` : `CMD` 역따옴표 안의 명령어를 해석하여 명령어의 결과로 보여준다.
[student@workstation ~]$ echo `date`
Mon Jul 22 01:16:14 AM EDT 2024

[student@workstation ~]$ echo "=====`date`======"
=====Mon Jul 22 01:16:43 AM EDT 2024======
최근에는 `가 아니라 $(CMD)
[student@workstation ~]$ echo $(date)
Mon Jul 22 01:17:29 AM EDT 2024
[student@workstation ~]$ echo "=====$(date)======"
=====Mon Jul 22 01:17:39 AM EDT 2024======

둘의 차이:
`cmd` : 단순하게 명령어를 실행하는 용도
$(cmd) : 임시 환경 변수를 만들어서 작업해야 하는 경우에 많이 사용. 

[student@workstation ~]$  var=$(hostname -s); echo $var 
workstation

쉘에서 임시 변수 지정
text=value
var=$(hostname -s)
; : 명령어의 격리
[student@workstation ~]$ echo ls
ls
[student@workstation ~]$ echo ; ls 

bin      Documents  file1  Pictures  Templates
Desktop  Downloads  Music  Public    Videos
;은 단순한 명령어에서 사용 하시기 바랍니다. 
그러면 단순하지 않은 명령은? = 민감한 명령 삭제. 이동. ..

[root@servera ~]# mkdir /test1
[root@servera ~]# mkdir /test2
[root@servera ~]# touch /test1/file1
[root@servera ~]# mkdir /test
[root@servera ~]# cd /test
[root@servera test]# pwd
/test

/test 라는 곳에서 /test1 아래 있는 모든 파일을 삭제
[root@servera test]# cd /test1 ; rm -rf *   << 요렇게 작업하려고 생각을 함
[root@servera test]# pwd
/test
[root@servera test]# touch file1
[root@servera test]# ls
file1
현재 디렉토리에 파일을 생성
[root@servera test]# cd /testq ; rm -rf *
-bash: cd: /testq: No such file or directory
[root@servera test]# ls
[root@servera test]# 
/test 밑의 파일이 삭제가 되었다.
위험: 이런 경우에는 ; 을 사용하면 안됨
그렇다면 무엇을 사용해야 할까?
[root@servera test]# touch file1
[root@servera test]# pwd
/test
[root@servera test]# ls
file1
&& : 앞의 명령어가 성공의 값일때만 뒤의 명령어를 실행
명령어의 리턴값이 0인 경우에만 뒤의 명령어를 실행
성공의 값 : 
[root@servera test]# ls
file1
[root@servera test]# echo $?
0
0 = 성공 정상
1-255 = 실패 에러

[root@servera test]# cd /testq &&  rm -rf *
-bash: cd: /testq: No such file or directory
[root@servera test]# ls
file1

|| : 명령어의 리턴값이 0이 아닌경우에만 뒤의 명령어를 실행
[root@servera test1]# cd /testq ||  echo 'two command'-bash: cd: /testq: No such file or directory
two command

둘을 합쳐보면 다음과 같이 이용
# CMD && CMD1 || CMD2

쉘 스크립트에서 출력 제공
[user@host ~]$ cat ~/bin/hello 

#!/usr/bin/bash   < 지시어
echo "Hello, world" < echo 명령을 통해 Hello, world를 실행, 출력

 [user@host ~]$ hello 
Hello, world 

[user@host ~]$ cat ~/bin/hello
#!/usr/bin/bash 
echo "Hello, world" 
echo "ERROR: Houston, we have a problem." >&2 

표준 입력 : STDIN: 따로 지정되지 않는 이상 키보드로 입력
표준 출력 : STDOUT: 따로 지정되지 않는 이상 모니터[터미널]로 출력
표준 에러 : STDERR: 따로 지정되지 않는 이상 모니터[터미널]로 출력

리다이렉션 : 파일이나 장치를 통해서 입력, 출력을 할 수 있다.
입력 리다이렉션: cat < file1 
[root@servera test]# echo 'RHEL9 rh134'
[root@servera test]# cat < file1
RHEL9 rh134
< : 표준 입력을 대신하여 파일에서 입력을 받는 용도
출력 리다이렉션: 
[root@servera test]# echo 'RHEL9 rh134'
RHEL9 rh134
[root@servera test]# echo 'RHEL9 rh134' > file1
[root@servera test]# cat file1
RHEL9 rh134
[root@servera test]# echo 'RHEL9 rh134' >> file1 
[root@servera test]# cat file1
RHEL9 rh134
RHEL9 rh134
[root@servera test]# echo 'RHCSA' > file1 
[root@servera test]# cat file1
RHCSA
> : 덮어쓰기, 표준 출력 리다이렉션
>> : 이어쓰기 

에러 리다이렉션:
리눅스는 에러와 출력을 따로 구분한다.
[root@servera test]# echo 111 > /dev/null 
[root@servera test]# cd /testq > /dev/null 
-bash: cd: /testq: No such file or directory

[root@servera test]# cd /testq 2> /dev/null 
[user@host ~]$ cat ~/bin/hello
#!/usr/bin/bash 
echo "Hello, world" 
echo "ERROR: Houston, we have a problem." >&2
 >&2 : 강제로 출력을 표준 에러로 변경

# CMD > file1 2>&1 :  표준 출력과 표준 에러를 file1 하나에 모두 담을때 

[24]
연습 가이드 사용법

연습 가이드 자체는 같이 하지는 않습니다.
시험 관련된 가이드 

[27]
스크립트에서 사용되는 반복문 / 조건문
반복문
for
while 
조건문
if

전체 시스템에서 부팅이 다 되었는가?
계정을 1-1000번까지 생성
openssl - 암호화 된 암호  생성 
useradd – password 
chage -d 0 


for문
for VARIABLE in LIST; do 
COMMAND VARIABLE
 done

for [변수] in [반복할 문자| 파일| 명령어로 숫자를 반복]; do 
실제 실행할 명령어 
sleep 1 < 반복문 이지만 한번씩 끊어서 작업 하기 위해 sleep으로 한 타임씩 끊어주기
done

변수:
보통 단일 문자로 많이 사용  특정한 문자열로 작성하는 것이 이후에 에러를 줄일수 있다.
[반복할 문자| 파일| 명령어로 숫자를 반복]
반복할 문자: 1 2 3 4 , a b c  d  반복문에서 사용할 문자를 수동으로 작성
파일 : `cat list`
명령어로 숫자를 반복: 
seq 1 100 
seq -w 1 100
001부터 시작




[root@servera ~]# for NUMBER in 1 2 3 4 ; do 
 > echo "hostname: lab.server${NUMBER}.example.com"
> done

변수로는 NUMBER 문자열 사용
반복된 숫자는 1- 4까지 사용
${NUMBER} 변수 지정시 중괄호 이용

반복문이 아닌 글로빙 기능을 사용하기
# touch file{1..10}
file1번에서 file10번까지 생성
bash shell 4.0 이상에서 제공 되는 기능

Bash 스크립트 종료 코드
쉘을 종료 할 때 에러 코드를 강제 삽입
스크립트가 하나로 이루어진게 아니라 이후 조건문을 위해 두개 이상의 스크립트가 결합되는 경우

https://blog.naver.com/mmarine/70094622832 


if?
조건식
if [조건] ; then
 조건이 맞는 경우의 실행
fi

if [조건] ; then
 조건이 맞는 경우의 실행
else 
 조건이 맞지않는 경우의 실행
fi

기본적으로 사용하면 좋은 for if 
while : 참인 경우 무한 반복

[root@servera test]# while true
> do
> echo "===========$(date)=========="
> sleep 1
> done

[root@servera test]# while true; do echo "===========$(date)=========="; sleep 1; done

1 while 
2 for
3 if

지금은 ansible 을 이용하게 되면 위의 조건식들을 더 쉽게 이용 할 수 있음

[35]

현재 레드햇 시험은 크게 두가지 형식으로 가능
오프라인 [특이한 경우에만 오픈] X
1 학동역 에티버스 , 패스트레인  : 키오스크 장비로 시험을 보는 방법
모든 장비가 갖춰져 있음. 몸만 가시면 바로 시험 진행 가능
2 remote exam : 온라인으로 시험을 진행
https://youtu.be/LX3VMIAuPzg?si=EB8FLuRGfzESX7gO
시험에 관련된 사항을 직접 준비.
RHEL DVD 라이브 부팅
네트워크
접속..
조용한 방 +컴퓨터
카메라  2개 
마이크 1개

시험 이후에 보통 30분 안에 결과가 날아옵니다.
PASS / NOPASS
210/300














[root@servera test]# cat list 
cat
dog
concatenate
dogma
category
educated
boondoggle
vindication
chilidog
위와 같은 파일을 생성

[root@servera test]# cat list  | grep cat 
cat
concatenate
category
educated
vindication
cat의 문자열 패턴을 검색

grep 명령이 각 라인별로 검사
문자열의 시작부분 그리고 끝 부분을 대상으로 검색 할 수 있음.

문자열의 시작 부분
[root@servera test]# cat list  | grep ^cat 
cat
category

문자열의 끝부분
[root@servera test]# cat list  | grep cat$
cat

[root@servera test]# cat /etc/ssh/sshd_config | grep port
# If you want to change the port on a SELinux system, you have to tell
# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER
# WARNING: 'UsePAM no' is not supported in Fedora and may cause several
[root@servera test]# cat /etc/ssh/sshd_config | grep -i port
# If you want to change the port on a SELinux system, you have to tell
# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER
#Port 22
# WARNING: 'UsePAM no' is not supported in Fedora and may cause several
#GatewayPorts no

grep를 이용하여 다음과 같이 나옴
/etc/passwd 파일에서 root 라는 단어가 들어있는 라인을 찾아 /root/lines.txt 파일로 생성
1.  순서대로 작성 할것
2. 빈칸이 없을것
3. 파일이 변화되면 안됨

grep을 이용한 특수문자 찾기
/etc 밑에서 다음 파일을 확인해 봅시다.
/etc/passwd
/etc/group
/etc/shadow
/etc/gshadow

ls -l /etc/passwd
ls -l /etc/group
ls -l /etc/shadow
ls -l /etc/gshadow

ls -l /etc/passwd-ls 
ls -l /etc/group-
ls -l /etc/shadow-
ls -l /etc/gshadow-

명령어의 체계
# CMD OP ARG
첫번째 오는건 무조건 명령어
두번째는 옵션
-a 짧은 옵션
–all 긴 옵션
a GNU 형식의 옵션
인자 : 파일이나 디렉토리를 받아 위치를 조정

[root@servera ~]# ls -l  /etc  | grep [-]$
-rw-r--r--.  1 root root      675 May 18  2022 group-
----------.  1 root root      540 May 18  2022 gshadow-
-rw-r--r--.  1 root root     1512 May 18  2022 passwd-
----------.  1 root root      942 May 18  2022 shadow-
-rw-r--r--.  1 root root       21 May 18  2022 subgid-
-rw-r--r--.  1 root root       21 May 18  2022 subuid-


 group-
그룹을 잘못 설정하게 되면 업데이트 되면서 기존의 모든 그룹설정이  업데이트되어 없어진다.
cat /etc/group- > /etc/group

[46] 랩 

vi bash-lab
echo ‘#!/usr/bin/bash’ >> bash-lab



















































