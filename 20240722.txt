깃허브
https://github.com/studylabdoc/text/blob/main/20240722.txt

구글드라이브
https://drive.google.com/drive/folders/1MIP3LQNU3oISKebgHWvUCgEVF4_2Xg95?usp=sharing

miro
https://miro.com/app/board/uXjVKwkVIgM=/?share_link_id=305482122361

google docs
https://docs.google.com/document/d/1vbzX5a2MGcT2SaKxQ3SR5XfKiK7ITvymUA98Fyz7eUI/edit?usp=sharing

[랩 접속 방법]
메일 : 20240722
rol.redhat.com  < RHLS 

MY VIRTUAL TRAINING CLASSES
RH134 - Red Hat System Administration II
Class Starts: 월, 7월 22 2024, 10:00 오전 

Class Ends: 금, 7월 26 2024, 06:00 오후 
JOIN

리소스 -> pdf download
랩 > workstation
Web Applications>  Classroom Web Terminal > access

PDF는 MS 엣지로 오픈
10:00 - 18:00 
쉬는시간 : 10 / 15분 
점심시간 : 12:30 - 14:00

[10] < 10page 

[7]
목차

RH134 과정을 위한 사전 명령어
# ls
디렉토리의 컨켄츠 확인
# chmod
권한 변경
# pwd
현재 디렉토리 확인
# passwd
비밀번호 변경
# useradd
계정 생성
# rm
삭제
# cp
복사
# mv
파일 이동 / 이름 변경
# date
시간 확인 / 시간변경 > timedatectl
# touch
파일의 시간 변경 , 빈 파일 생성
# mkdir
디렉토리 생성
# rmdir
빈 디렉토리 삭제 -> rm -rf dir
# id
현재 계정의 정보 확인
UID / GID / groups / selinux data
# cat
파일 확인 / 파일 병합 > 표준 출력 
# tac
파일 출력 방향을 반대로 돌림
# ps
프로세스 확인 / ps / ps -ef / ps aux
# bash
사용자 쉘 명령 / 서브 쉘을 실행 최근에는 bash도 사용하지만 fish / zsh 도 많이 사용중
# su -
접속 된 계정이 아닌 새로운 계정으로 전환 / 최근에는 sudo 명령 권장
# echo
빈 한 줄을 리턴 / 환경변수 호출
# more
cat의 경우에는 라인이 길어도 모두 한번에 출력
페이지 단위로 한 페이지 씩 끊어서 화면에 출력
more와 man에서 사용되는 기능키
* spacebar : 매뉴얼 페이지에서 한 화면 단위로 넘어 갈 때 사용
Enter : 매뉴얼 페이지에서 한 라인씩 넘어 갈 때 사용
b : Back Screen, 한 화면 전 화면으로 넘어갈 때 사용
* /pattern : 특정한 패턴을 빨리 찾을 때 사용
* n : Next, 특정한 패턴을 찾은 후 다음 번째 똑같은 문자열을 찾을 때 사용
h : help 매뉴얼 페이지 안에서 사용 할 수 있는 명령어 소개
* q : quit, 빠져나옴
# man
도움말 
https://linux.die.net/man/
# clear
화면을 청소 / 청소 이후 위의 출력 결과를 알수가 없음
# ln
출력 결과의 앞에 번호를 붙임
# tree
파일시스템의 파일, 디렉토리의 구조화
# dnf
yum, dnf 패키지 관리 프로그램
# chown
소유자 변경 
# umask
기본 권한 변경, 확인
# which
명령어 절대경로 확인
# whereis
매뉴얼 확인
# alias
기본 명령이 아닌 쉽게 사용할 수 있는 약어 생성, 확인
# histroy
사용한 명령어를 확인
# stat
전체 시간 정보 + 권한등 여러가지를 확인
# file
파일의 형식 확인
# cat file1 file2 > file3
표준 출력의 리다이렉션
# find . -name core 2> /dev/null
표준 에러의 리다이렉션
# cat < file1
표준 입력의 리다이렉션
# ssh
원격 접속을 위한 보안 쉘
# scp
원격 파일 복사를 위한 보안 쉘 [사용을 현재 중지]
# sftp
보안 파일 전송 프로토콜
# script
화면에 출력되는 모든 텍스트를 캡처, 저장
# vi
텍스트 에디터
# systemctl
systemd를 위한 명령어
# exit
쉘을 빠져나가기
# export
환경 변수 지정
# ^c
현재 작업중인 내용을 인터럽트하고 강제 종료
# ^d
EOF / EXIT
EOF: 파일의 끝
EXIT: 쉘을 끝내는 단축키
# poweroff
시스템 종료
# reboot
재부팅
# shutdown
시스템 종료 / 유예시간을 부여 할 수 있다. 
# ping
ICMP 프로토콜을 이용하여 헬스 체크 / 조건문에서 사용하기 위해 작성
# ifconfig
NIC 정보 확인 > 최근에는 잘 사용되지 않음.
net-tools 패키지가 있어야 하지만 설치자체를 하지 않음.
ip a 명령으로 대체
# head
파일의 상단 10줄
# tail
파일의 하단 10줄
# who
현재 접속자 확인
# last
사용자들의 접속 기록
# lastb
사용자의 잘못된 접속 기록
# w
현재 접속자의 사용 명령 확인
# while true do ; action ; done
반복문
# df
디스크의 남은 용량 / 파일 시스템 확인
# du
디스크의 사용 용량
# sort
데이터 정렬
# uniq 
데이터의 값 중 유일한 것 하나만 추출
# tee
출력을 두 방향으로 복제
# screen
지금은 tmux 명령으로 변경
쉘을 이용하면 쉘이 꺼지게 되면 작업 중지
내부에서 백 그라운드 작업으로 돌기 때문에 쉘이 꺼져도 계속 작업이 가능.
# mail
s-nail 명령으로 변환
# wall 
현재 실행중인 모든 터미널에 동일한 내용으로 브로드캐스트 
# grep
컨텐츠 내에서 특정 패턴을 찾기 위해 사용
+ 특정 패턴을 걸고 디렉토리나 파일에서 해당 내용이 존재하는 파일을 찾는 용도
# find
inode 정보를 필터링 하여 원하는 파일 / 디렉토리를 찾는 용도
+ 검색된 파일과 디렉토리에 실행 명령을 내려 2차 작업이 가능 

124 / 134 / 199 -> RHCSA

시험을 대비하는 분들을 위해:
1장
연습가이드: 간단한 Bash 스크립트 작성
2장
연습가이드: 반복 실행 사용자 작업 예약
3장
연습가이드: 정확한 시간 유지 관리
4장
연습 가이드: 압축된 tar 아카이브 관리 
tar + gz , bzip2, xz 
5장
연습가이드: 튜닝 프로파일 조정
6장
연습 가이드: SELinux 문제 조사 및 해결
+ 11장 연습 가이드: SELinux 포트 레이블 지정 제어
+ 연습 가이드: 서버 방화벽 관리

7장 8장 all
block storage를 마운트 하고 fstab까지 구성이 가능한 상태 >
LVM 구성 
+ LVM 생성
+ LVM 확장
+ swap

9장
연습 가이드: 네트워크 연결 스토리지 자동 마운트

10장
연습 가이드: 루트 암호 재설정

13장
container build 
container image control
연습 가이드: 컨테이너를 시스템 서비스로 관리

[14]
강의실 환경에 대한 오리엔테이션
workstation : 작업을 위한 컴퓨터
servera,serverb : 실제 작업을 위한 서버 
나머지 서버들은 lab 환경을 위해 존재한다.

시스템의 계정들은 다음과 같다.
student / student
root / redhat

1장
[20]
스크립트 = 자동화
쉘 스크립트, perl, -> [ansible:RHCE:RH294]

스크립트 top-down 
리눅스에 존재하는 왠만한 파일들은 위에서 아래로 읽어 내려감
1 shell을 사용한다는 것을 명시
2 명령어 작성

# vi run.sh
리눅스에서는 파일명 끝의 확장자는 아무 의미 없음.

명령 인터프리터 지정
# < 주석 처리로 진행이 되지만 첫줄에서 #! -> 이 뒤에 오는 파일 명을 가지고 쉘을 실행
sample
#!/usr/bin/bash == #!/bin/bash

실제 사용할 명령 리스트 순서대로 진행

date
echo 'run.sh file'
sleep 2
echo 'run.sh exit'


$ vi run.sh
---------------------------
#!/usr/bin/bash
date
echo 'run.sh file'
sleep 2
echo 'run.sh exit'
---------------------------

i : 입력모드
입력
esc -> 명령행모드
:wq  -> 저장+ 빠져나가기

현재 쉘에서 실행하기
./run.sh
./ = 현재 디렉토리 
run.sh = 실제 사용할 파일
./= /home/student/
./run.sh = /home/student/run.sh
실행을 위해서는 x권한이 필요
[student@workstation ~]$ ls -l run.sh
-rw-r--r--. 1 student student 67 Jul 21 23:12 run.sh
[student@workstation ~]$ chmod u+x run.sh
[student@workstation ~]$ ls -l run.sh
-rwxr--r--. 1 student student 67 Jul 21 23:12 run.sh

명령어를 호출하는 순서
1 hash에서 검색 
  # hash , # hash -r 
2 alias 에서 확인
3 실제 경로를 확인
4 명령어 실행

# command ls
alias 무시후 실제 경로에서만 실행

[student@workstation ~]$ echo $PATH
/home/student/.local/bin:/home/student/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/home/student/.venv/labs/bin
PATH 환경변수는 명령어를 입력 했을때 3번[실제 경로를 확인] 작업을 위한 디렉토리를 모아둔 곳

실제 경로를 확인
[student@workstation ~]$ ls
Desktop    Downloads  Music     Public  Templates
Documents  file1      Pictures  run.sh  Videos
[student@workstation ~]$ mkdir bin
[student@workstation ~]$ mv run.sh bin
[student@workstation ~]$ tree bin
bin
└── run.sh

0 directories, 1 file
run.sh 파일을 bin 디렉토리 아래에 복사.
해당 디렉토리는 /home/student/bin에 존재

0 directories, 1 file
run.sh 파일을 bin 디렉토리 아래에 복사.
해당 디렉토리는 /home/student/bin에 존재

인용 특수 문자 -> 메타캐릭터
shell에서 특수문자를 파일명에 추가 하지 마라.
!@#$%^&*()_ | ‘ “ ; : , . / \ ~ `  -> 쉘에서 하는 기능들이 있다.
명령어 입력 -> 
# ls -l $(which ls)
> 토큰 단위로 분할 [빈칸 ]
1  ls
2  -l
3  $(which ls)
쉘에서는 특수문자를 기능으로 사용을 한다.
파일을 생성 할때:
255 자.
빈칸 쓰지말고
특수문자 쓰지말고
영문자, 대문자, 숫자, -, _ , . 만 가지고 생성
자주 사용되는 메타캐릭터:
# : 주석 처리
\:
1 바로 뒤에 오는 한가지 문자를 해석하지 않음
[student@workstation ~]$ echo \$HOME
$HOME
2 명령어 라인의 끝에 \를 붙이게 되면 PS2 변수를 반환 하면서 라인을 끝내지 않고 아래줄에서 이어서 작성
‘ : ‘text’따옴표 안의 문자열을 해석하지 않음
“: “text”따옴표 안의 문자열을 해석하지 않음 [하지만 해석하는 문자도 있다. \ ` $]
` : `CMD` 역따옴표 안의 명령어를 해석하여 명령어의 결과로 보여준다.
[student@workstation ~]$ echo `date`
Mon Jul 22 01:16:14 AM EDT 2024

[student@workstation ~]$ echo "=====`date`======"
=====Mon Jul 22 01:16:43 AM EDT 2024======
최근에는 `가 아니라 $(CMD)
[student@workstation ~]$ echo $(date)
Mon Jul 22 01:17:29 AM EDT 2024
[student@workstation ~]$ echo "=====$(date)======"
=====Mon Jul 22 01:17:39 AM EDT 2024======

둘의 차이:
`cmd` : 단순하게 명령어를 실행하는 용도
$(cmd) : 임시 환경 변수를 만들어서 작업해야 하는 경우에 많이 사용. 

[student@workstation ~]$  var=$(hostname -s); echo $var 
workstation

쉘에서 임시 변수 지정
text=value
var=$(hostname -s)
; : 명령어의 격리
[student@workstation ~]$ echo ls
ls
[student@workstation ~]$ echo ; ls 

bin      Documents  file1  Pictures  Templates
Desktop  Downloads  Music  Public    Videos
;은 단순한 명령어에서 사용 하시기 바랍니다. 
그러면 단순하지 않은 명령은? = 민감한 명령 삭제. 이동. ..

[root@servera ~]# mkdir /test1
[root@servera ~]# mkdir /test2
[root@servera ~]# touch /test1/file1
[root@servera ~]# mkdir /test
[root@servera ~]# cd /test
[root@servera test]# pwd
/test

/test 라는 곳에서 /test1 아래 있는 모든 파일을 삭제
[root@servera test]# cd /test1 ; rm -rf *   << 요렇게 작업하려고 생각을 함
[root@servera test]# pwd
/test
[root@servera test]# touch file1
[root@servera test]# ls
file1
현재 디렉토리에 파일을 생성
[root@servera test]# cd /testq ; rm -rf *
-bash: cd: /testq: No such file or directory
[root@servera test]# ls
[root@servera test]# 
/test 밑의 파일이 삭제가 되었다.
위험: 이런 경우에는 ; 을 사용하면 안됨
그렇다면 무엇을 사용해야 할까?
[root@servera test]# touch file1
[root@servera test]# pwd
/test
[root@servera test]# ls
file1
&& : 앞의 명령어가 성공의 값일때만 뒤의 명령어를 실행
명령어의 리턴값이 0인 경우에만 뒤의 명령어를 실행
성공의 값 : 
[root@servera test]# ls
file1
[root@servera test]# echo $?
0
0 = 성공 정상
1-255 = 실패 에러

[root@servera test]# cd /testq &&  rm -rf *
-bash: cd: /testq: No such file or directory
[root@servera test]# ls
file1

|| : 명령어의 리턴값이 0이 아닌경우에만 뒤의 명령어를 실행
[root@servera test1]# cd /testq ||  echo 'two command'-bash: cd: /testq: No such file or directory
two command

둘을 합쳐보면 다음과 같이 이용
# CMD && CMD1 || CMD2

쉘 스크립트에서 출력 제공
[user@host ~]$ cat ~/bin/hello 

#!/usr/bin/bash   < 지시어
echo "Hello, world" < echo 명령을 통해 Hello, world를 실행, 출력

 [user@host ~]$ hello 
Hello, world 

[user@host ~]$ cat ~/bin/hello
#!/usr/bin/bash 
echo "Hello, world" 
echo "ERROR: Houston, we have a problem." >&2 

표준 입력 : STDIN: 따로 지정되지 않는 이상 키보드로 입력
표준 출력 : STDOUT: 따로 지정되지 않는 이상 모니터[터미널]로 출력
표준 에러 : STDERR: 따로 지정되지 않는 이상 모니터[터미널]로 출력

리다이렉션 : 파일이나 장치를 통해서 입력, 출력을 할 수 있다.
입력 리다이렉션: cat < file1 
[root@servera test]# echo 'RHEL9 rh134'
[root@servera test]# cat < file1
RHEL9 rh134
< : 표준 입력을 대신하여 파일에서 입력을 받는 용도
출력 리다이렉션: 
[root@servera test]# echo 'RHEL9 rh134'
RHEL9 rh134
[root@servera test]# echo 'RHEL9 rh134' > file1
[root@servera test]# cat file1
RHEL9 rh134
[root@servera test]# echo 'RHEL9 rh134' >> file1 
[root@servera test]# cat file1
RHEL9 rh134
RHEL9 rh134
[root@servera test]# echo 'RHCSA' > file1 
[root@servera test]# cat file1
RHCSA
> : 덮어쓰기, 표준 출력 리다이렉션
>> : 이어쓰기 

에러 리다이렉션:
리눅스는 에러와 출력을 따로 구분한다.
[root@servera test]# echo 111 > /dev/null 
[root@servera test]# cd /testq > /dev/null 
-bash: cd: /testq: No such file or directory

[root@servera test]# cd /testq 2> /dev/null 
[user@host ~]$ cat ~/bin/hello
#!/usr/bin/bash 
echo "Hello, world" 
echo "ERROR: Houston, we have a problem." >&2
 >&2 : 강제로 출력을 표준 에러로 변경

# CMD > file1 2>&1 :  표준 출력과 표준 에러를 file1 하나에 모두 담을때 

[24]
연습 가이드 사용법

연습 가이드 자체는 같이 하지는 않습니다.
시험 관련된 가이드 

[27]
스크립트에서 사용되는 반복문 / 조건문
반복문
for
while 
조건문
if

전체 시스템에서 부팅이 다 되었는가?
계정을 1-1000번까지 생성
openssl - 암호화 된 암호  생성 
useradd – password 
chage -d 0 


for문
for VARIABLE in LIST; do 
COMMAND VARIABLE
 done

for [변수] in [반복할 문자| 파일| 명령어로 숫자를 반복]; do 
실제 실행할 명령어 
sleep 1 < 반복문 이지만 한번씩 끊어서 작업 하기 위해 sleep으로 한 타임씩 끊어주기
done

변수:
보통 단일 문자로 많이 사용  특정한 문자열로 작성하는 것이 이후에 에러를 줄일수 있다.
[반복할 문자| 파일| 명령어로 숫자를 반복]
반복할 문자: 1 2 3 4 , a b c  d  반복문에서 사용할 문자를 수동으로 작성
파일 : `cat list`
명령어로 숫자를 반복: 
seq 1 100 
seq -w 1 100
001부터 시작




[root@servera ~]# for NUMBER in 1 2 3 4 ; do 
 > echo "hostname: lab.server${NUMBER}.example.com"
> done

변수로는 NUMBER 문자열 사용
반복된 숫자는 1- 4까지 사용
${NUMBER} 변수 지정시 중괄호 이용

반복문이 아닌 글로빙 기능을 사용하기
# touch file{1..10}
file1번에서 file10번까지 생성
bash shell 4.0 이상에서 제공 되는 기능

Bash 스크립트 종료 코드
쉘을 종료 할 때 에러 코드를 강제 삽입
스크립트가 하나로 이루어진게 아니라 이후 조건문을 위해 두개 이상의 스크립트가 결합되는 경우

https://blog.naver.com/mmarine/70094622832 


if?
조건식
if [조건] ; then
 조건이 맞는 경우의 실행
fi

if [조건] ; then
 조건이 맞는 경우의 실행
else 
 조건이 맞지않는 경우의 실행
fi

기본적으로 사용하면 좋은 for if 
while : 참인 경우 무한 반복

[root@servera test]# while true
> do
> echo "===========$(date)=========="
> sleep 1
> done

[root@servera test]# while true; do echo "===========$(date)=========="; sleep 1; done

1 while 
2 for
3 if

지금은 ansible 을 이용하게 되면 위의 조건식들을 더 쉽게 이용 할 수 있음

[35]

현재 레드햇 시험은 크게 두가지 형식으로 가능
오프라인 [특이한 경우에만 오픈] X
1 학동역 에티버스 , 패스트레인  : 키오스크 장비로 시험을 보는 방법
모든 장비가 갖춰져 있음. 몸만 가시면 바로 시험 진행 가능
2 remote exam : 온라인으로 시험을 진행
https://youtu.be/LX3VMIAuPzg?si=EB8FLuRGfzESX7gO
시험에 관련된 사항을 직접 준비.
RHEL DVD 라이브 부팅
네트워크
접속..
조용한 방 +컴퓨터
카메라  2개 
마이크 1개

시험 이후에 보통 30분 안에 결과가 날아옵니다.
PASS / NOPASS
210/300














[root@servera test]# cat list 
cat
dog
concatenate
dogma
category
educated
boondoggle
vindication
chilidog
위와 같은 파일을 생성

[root@servera test]# cat list  | grep cat 
cat
concatenate
category
educated
vindication
cat의 문자열 패턴을 검색

grep 명령이 각 라인별로 검사
문자열의 시작부분 그리고 끝 부분을 대상으로 검색 할 수 있음.

문자열의 시작 부분
[root@servera test]# cat list  | grep ^cat 
cat
category

문자열의 끝부분
[root@servera test]# cat list  | grep cat$
cat

[root@servera test]# cat /etc/ssh/sshd_config | grep port
# If you want to change the port on a SELinux system, you have to tell
# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER
# WARNING: 'UsePAM no' is not supported in Fedora and may cause several
[root@servera test]# cat /etc/ssh/sshd_config | grep -i port
# If you want to change the port on a SELinux system, you have to tell
# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER
#Port 22
# WARNING: 'UsePAM no' is not supported in Fedora and may cause several
#GatewayPorts no

grep를 이용하여 다음과 같이 나옴
/etc/passwd 파일에서 root 라는 단어가 들어있는 라인을 찾아 /root/lines.txt 파일로 생성
1.  순서대로 작성 할것
2. 빈칸이 없을것
3. 파일이 변화되면 안됨

grep을 이용한 특수문자 찾기
/etc 밑에서 다음 파일을 확인해 봅시다.
/etc/passwd
/etc/group
/etc/shadow
/etc/gshadow

ls -l /etc/passwd
ls -l /etc/group
ls -l /etc/shadow
ls -l /etc/gshadow

ls -l /etc/passwd-ls 
ls -l /etc/group-
ls -l /etc/shadow-
ls -l /etc/gshadow-

명령어의 체계
# CMD OP ARG
첫번째 오는건 무조건 명령어
두번째는 옵션
-a 짧은 옵션
–all 긴 옵션
a GNU 형식의 옵션
인자 : 파일이나 디렉토리를 받아 위치를 조정

[root@servera ~]# ls -l  /etc  | grep [-]$
-rw-r--r--.  1 root root      675 May 18  2022 group-
----------.  1 root root      540 May 18  2022 gshadow-
-rw-r--r--.  1 root root     1512 May 18  2022 passwd-
----------.  1 root root      942 May 18  2022 shadow-
-rw-r--r--.  1 root root       21 May 18  2022 subgid-
-rw-r--r--.  1 root root       21 May 18  2022 subuid-


 group-
그룹을 잘못 설정하게 되면 업데이트 되면서 기존의 모든 그룹설정이  업데이트되어 없어진다.
cat /etc/group- > /etc/group

[46] 랩 

vi bash-lab
echo ‘#!/usr/bin/bash’ >> bash-lab

[54] 

at
crontab  << * 
anacron
timer

at: 1회성 작업을 위한 스케쥴러
른 예는 방화벽 구성 작업 중인 시스템 관리자가 새 방화벽 구성이 작동했기 때문에 방화벽 설정을 10분 이내에 이전의 작업 상태로 재설정하기 위해 안전 작업 을 대기열에 추가하는 경우  << 현재 firewalld를 사용하면 이 구성은 굳이 필요없다.
방화벽 구성
at을 이용해서 10분뒤에 원복하면 된다.
현재 firewalld를 이용하는 경우에는 timer 옵션으로 원상태로 복구 가능하기 때문에 약간 틀린 예시: CMD –timeout 600 

실제 예시: 
다른 시스템이 재부팅 : 재부팅 이후에 체크, 재부팅 이후 접속
 
명령어 : at
데몬 [서비스] : atd 
[root@servera ~]# systemctl status atd
 atd.service - Deferred execution scheduler
     Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled; vendor preset: enabled)
     Active: active (running) since Sun 2024-07-21 21:47:36 EDT; 23h ago
       Docs: man:atd(8)
   Main PID: 803 (atd)
      Tasks: 1 (limit: 10799)
     Memory: 312.0K
        CPU: 13ms
     CGroup: /system.slice/atd.service
             └─803 /usr/sbin/atd -f

Jul 21 21:47:36 servera.lab.example.com systemd[1]: Started Deferred execution scheduler.





서비스 파일 설명
[root@servera ~]# systemctl status atd
atd.service - Deferred execution scheduler : 데몬[서비스]명 확인
     Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled; vendor preset: enabled)
     서비스 파일에 대해서 읽은 상태 |실제 파일 위치 | 활성화 정보 
     Active: active (running) since Sun 2024-07-21 21:47:36 EDT; 23h ago
      현재 상태 
       Docs: man:atd(8)
       사용 가능한 도움말
   Main PID: 803 (atd)
       현재 사용중인 PID 번호 확인
      Tasks: 1 (limit: 10799)
     Memory: 312.0K
        CPU: 13ms
     CGroup: /system.slice/atd.service
             └─803 /usr/sbin/atd -f

Jul 21 21:47:36 servera.lab.example.com systemd[1]: Started Deferred execution scheduler.
로그 중에 atd 와 관련있는 로그들을 추출하여 status 출력시 최신 로그를 같이 보여준다.

작업:
1 현재 시간을 확인
[root@servera log]# date   < 시간을 확인
Mon Jul 22 09:20:41 PM EDT 2024
[root@servera log]# at 09:25   < at 명령을 실행 TIMESPEC 지정
warning: commands will be executed using /bin/sh
at> logger 'test at'
at> <EOT>
job 1 at Tue Jul 23 09:25:00 2024


[root@servera log]# at 09:25  < file1   : 작업을 수동으로 입력하지 않고 파일에서 작업을 불러온다.

[root@servera log]# atq
1       Tue Jul 23 09:25:00 2024 a root
현재 지정된 작업들을 확인

[root@servera log]# at -c 1

마지막 부분에서 실제 사용한 명령을 확인 할 수 있다.

[root@servera log]# atrm 1 
at의 작업을 삭제 하는 용도

[59]
crontab

[root@servera ~]# cat /etc/crontab 
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
변수처리된 부분은 top-down 형식으로 진행되기 때문에 변수가 지정된 이후 모든 작업에 적용된다.

# For details see man 4 crontabs

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed

[1] [2] [3] [4] [5] [user-name] [command to be executed]

각 자리가 표시 하는것 
[1]: 분
[2]: 시
[3]: 일
[4]: 월
[5]: 주

각 자리가 표시 하는것 + 숫자의 범위
[1]: 분 0-59
[2]: 시 0-23
[3]: 일 1-31
[4]: 월 1-12
[5]: 주 0-6  0==7  1-5 월-금 6 토 일0,7 



각 자리가 표시 하는것 + 숫자의 범위 + 표시 되는 형식에서 알아야 하는것
주의 사항을 알아보자

[1]: 분 0-59
0분을 사용하지 말것
모든 시간의 0분에는 시스템에서 사용되는 스케쥴러들이 많이 돌아간다.
[2]: 시 0-23
0시는 제외
하루가 시작되는 시간에 모든 초기화 작업, 정보 수집이 새로 시작되는데 이때 크론을 걸게 되면 부하가 심해짐
[3]: 일 1-31
1 제외
30일,28일,27
[4]: 월 1-12
[5]: 주 0-6  0==7  1-5 월-금 6 토 일0,7 
사용하는 사람들마다 0과 7을 섞어서 사용함.
팀에서 포맷 맞춰서 사용

숫자를 이용할때 사용 가능한 형식
[1]: 분 0-59

* 모든 시간을 지정

10 : 10분이라는 시간에 지정

10,15 10분,15분이라는 시간에 지정

10-15 10,11,12,13,14,15 분이라는 시간에 지정

10-15,20 10,11,12,13,14,15,20 분이라는 시간에 지정

*/N  N분에 한번씩
*/2 2분에 한번씩
*/10 10분에 한번씩

*/N 단점:  크론탭은 1분에 한번씩 동작
*/10  10분에 한번씩 로그를 출력해야겠다.
*/10 * * * * PATH/script.log

XXXX  XX XX XX:10
XXXX  XX XX XX:20
XXXX  XX XX XX:30
XXXX  XX XX XX:40

reboot, restart : 부팅 이후 시간기준으로 10분간격
service start time XXXX  XX XX XX:16
XXXX  XX XX XX:16
XXXX  XX XX XX:26
XXXX  XX XX XX:36
XXXX  XX XX XX:46

[user-name] [command to be executed]

[user-name] 이전방식 : /etc/crontab 파일에서 사용하다보니 어떤 사용자로 실행 할 것인가를 지정
 [command to be executed] 실행 파일을 지정 실행 권한도 같이 필요.

과거에는 /etc/crontab 파일에 작성을 root 계정으로 하고 관리도 root가 진행
현재:  더이상 /etc/crontab 파일에 작성하지 않는다. 이 파일은 이제 참고용 파일로 남겨둠

각각 계정별로 작업을 한다.
1 root 계정으로 각 사용자 파일을 생성
[root@servera cron]# crontab -e -u student
2 실제 사용자 계정으로 파일을 생성
[root@servera cron]# su -  student
Last login: Mon Jul 22 02:15:38 EDT 2024 from 172.25.250.9 on pts/0
[student@servera ~]$ crontab -e 

# crontab 
-l : crontab 파일을 확인
-e : crontab 파일을 수정
-r:  crontab 파일을 삭제
-u [계정] 위 명령들을 현재 사용자가 아니라 특정 사용자로 지정하여 진행

[root@servera ~]# cd
[root@servera ~]# id
uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

[root@servera ~]# crontab -l
no crontab for root   < 현재는 크론 파일이 생성되지 않음.

[root@servera ~]# crontab -e

"/tmp/crontab.Y7L9LY" 0L, 0B   << crontab  파일의 경우는 임시파일로 생성 한뒤 실제 파일로 변환
i
*/2 * * * * logger 'test log'
esc
:wq

crontab: installing new crontab   < 정상 저장이 완료

[root@servera ~]# cd /var/spool/cron/
[root@servera cron]# pwd
/var/spool/cron
[root@servera cron]# ls
root
[root@servera cron]# file root
root: ASCII text
[root@servera cron]# cat root 
*/2 * * * * logger 'test log'
[root@servera cron]# crontab -l
*/2 * * * * logger 'test log'

[root@servera cron]# crontab -e -u student 
*/2 * * * * logger 'test log student'
[root@servera cron]# ls -l
total 8
-rw-------. 1 root root 30 Jul 22 22:17 root
-rw-------. 1 root root 38 Jul 22 22:19 student
생성된 파일의 경우에는 root 권한으로 생성 되지만 상관 없음.
실제 진행되는 프로세스는  student 파일명으로 동일한 계정에서 실행

[root@servera cron]# journalctl | grep 'test log'
Jul 22 22:18:01 servera.lab.example.com CROND[2662]: (root) CMD (logger 'test log')
Jul 22 22:18:01 servera.lab.example.com root[2662]: test log
Jul 22 22:18:01 servera.lab.example.com CROND[2660]: (root) CMDEND (logger 'test log')
Jul 22 22:20:01 servera.lab.example.com CROND[2685]: (root) CMD (logger 'test log')
Jul 22 22:20:01 servera.lab.example.com root[2685]: test log
Jul 22 22:20:01 servera.lab.example.com CROND[2680]: (root) CMDEND (logger 'test log')
Jul 22 22:20:01 servera.lab.example.com CROND[2696]: (student) CMD (logger 'test log student')
Jul 22 22:20:01 servera.lab.example.com student[2696]: test log student
Jul 22 22:20:01 servera.lab.example.com CROND[2681]: (student) CMDEND (logger 'test log student')
현재 crontab에 지정한 내용들이 정상 동작중이다.

[root@servera cron]# ls
root  student
[root@servera cron]# crontab -r 
[root@servera cron]# ls
student
[root@servera cron]# rm -rf student 
[root@servera cron]# crontab -u student -l
no crontab for student

crontab은 저장 하는 순간부터 진행

[root@servera cron]# systemctl status crond
● crond.service - Command Scheduler
     Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled)
     Active: active (running) since Sun 2024-07-21 21:47:36 EDT; 24h ago
   Main PID: 804 (crond)
      Tasks: 1 (limit: 10799)
     Memory: 1.3M
        CPU: 1.163s
     CGroup: /system.slice/crond.service
             └─804 /usr/sbin/crond -n

Jul 22 20:01:01 servera.lab.example.com CROND[2408]: (root) CMD (run-parts /etc/cron.hourly)

프로세스의 진행 시간을 확인 하는 명령어
[root@servera cron]# cd 
[root@servera ~]# dd if=/dev/zero of=/root/bigfile bs=1M count=1024
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.09995 s, 511 MB/s
[root@servera ~]# ls
bigfile  lines.txt  list  list1
[root@servera ~]# file bigfile 
bigfile: data


[root@servera ~]# time dd if=/dev/zero of=/root/bigfile bs=1M count=1024
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.4091 s, 446 MB/s

real    0m2.474s   << * 
user    0m0.003s
sys     0m0.683s

# man crond
# man -s 5 crontab
# man -s 8 crontab

[62]
시험에서 crontab 이 출제 
2.3 구문

 [65]
반복 실행 시스템 작업 예약 

[root@servera ~]# cd /etc/cron.
cron.d/   : 반복 실행될 시스템 작업에 대한 예약
cron.hourly/ :시간에 동작
cron.weekly/ :  주에 한번 동작
cron.daily/ : 일에 한번 동작
cron.monthly/ :  월에 한번 동작
[root@servera ~]# cd /etc/cron.d
[root@servera cron.d]# ls
0hourly
[root@servera cron.d]# 
[root@servera cron.d]# cat 0hourly 
# Run the hourly jobs
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
01 * * * * root run-parts /etc/cron.hourly
run-parts : 특정 디렉토리에 있는 스크립트를 실행하는 데 사용하는 명령


anacron
crontab과의 차이점: 
crontab의 경우에는 사용자 관점
anacron의 경우에는 시스템 관점
crontab의 경우는 충돌이나 재부팅등 사용이 불가능한 상황에 놓여 시간을 놓치게 된다면 해당 작업을 무시. 그 다음 시간대에 작업을 재개
anacron의 경우는  충돌이나 재부팅등 사용이 불가능한 상황이 오게 되면 그 이후 재부팅, 충돌에 대한 해결이 된 다음 곧 바로 작업을 재개

[root@servera cron.hourly]# cat /etc/anacrontab 
# /etc/anacrontab: configuration file for anacron

# See anacron(8) and anacrontab(5) for details.

SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
# the maximal random delay added to the base delay of the jobs
RANDOM_DELAY=45
# the jobs will be started during the following hours only
START_HOURS_RANGE=3-22

#period in days    | delay in minutes  |  job-identifier  |  command
 1                                 5                                  cron.daily              nice run-parts /etc/cron.daily
 7                                 25                               cron.weekly           nice run-parts /etc/cron.weekly
@monthly                 45                                cron.monthly            nice run-parts /etc/cron.monthly
[root@servera cron.hourly]# cat /etc/anacrontab  | tail -4 | column -t

timer

init > systemd

systemd에서 사용 가능한 timer 유닛
현재 anacron의 경우에는 timer 유닛으로 모두 변경
[root@servera cron.hourly]# systemctl -t timer
  UNIT                         LOAD   ACTIVE SUB     DESCRIPTION                           
  dnf-makecache.timer          loaded active waiting dnf makecache --timer
  logrotate.timer              loaded active waiting Daily rotation of log files
  mlocate-updatedb.timer       loaded active waiting Updates mlocate database every day
  systemd-tmpfiles-clean.timer loaded active waiting Daily Cleanup of Temporary Directories

timer의 장점:
crontab은 1분에 한번 작용
timer는 초단위 가능

/tmp
/var/tmp

[68] 실습

[84]
시스템 로그 아키텍처 설명

로그 : 시스템 감사 및 문제 해결에 사용 , 이벤트에 대한 기록
로그는 보통 텍스트 파일로 구성 되어있지만 모두가 그런것은 아님

[root@servera ~]# cd /var/log
[root@servera log]# ls
audit                  dnf.librepo.log  maillog   spooler
boot.log               dnf.log          messages  sssd
boot.log-20240722      dnf.rpm.log      private   tallylog
btmp                   firewalld        qemu-ga   tuned
chrony                 hawkey.log       README    wtmp
cloud-init.log         insights-client  rhsm
cloud-init-output.log  kdump.log        samba
cron                   lastlog          secure
[root@servera log]# file * | grep -v  empty | grep -v directory | grep -v ASCII | grep -v text | grep -v symbolic
lastlog:               data
wtmp:                  data
 
data 파일의 경우에는 텍스트가 아니기 때문에 바로 읽을수 없음
특정 명령을 이용해야만 가능한 경우들도 있다.
로그 파일이든 뭐든 사용자가 직접 생성한 파일이 아닌 경우에는 
file 명령을 통해서 형식을 확인하는 것이 좋다.
[root@servera log]# file lastlog
lastlog: data
[root@servera ~]# ls
bigfile  lines.txt  list  list1
[root@servera ~]# file bigfile 
bigfile: data

[root@servera ~]# journalctl  현재부팅 이후부터 모든 로그를 가지고 있음
[root@servera ~]# journalctl -f 최근의 로그만 확인


systemd-journald  재부팅 후 유지되지 않는 파일 시스템에 저장 /run 밑에서 사용을 하기 때문에 그렇다.

syslog / rsyslog
사용되는 용어들도 알아야 하고 나오는 메시지도 봐야 하고 ..

syslog 기능 개요
메세지 종류  설  명
authpriv    개인 인증을 요하는 프로그램 유형이 발생한 메세지(EX: su, telnet, ssh)
cron        crontab(crond), at(atd) 프로그램이 발생한 메세지(EX: crontab, at)
daemon      시스템 데몬이 생성한 메세지. (EX: telnetd, ftpd) 
kern        커널이 발생한 메세지
lpr         프린트 유형의 프로그램이 발생한 메세지
mail        메일시스템이 발생한 메세지.
mark        syslogd 데몬에 의해 생성된 일정한 시간간격의 반복적인 메세지
news        유즈넷 뉴스 프로그램 유형이 발생한 메세지
security(auth)  인증 프로그램이 생성한 메세지(EX: login)
syslog     syslog 프로그램이 생성한 메세지(EX: syslogd)
user       사용자 프로그램에 의해 생성된 메세지(EX: top, system-config-*)
uucp       UUCP(Unix to Unix Copy) 시스템이 발생한 메세지
local0-7   예약된 메세지 종류, 여분으로 남겨둔 유형(EX: local0, local1, local2, ...)
*          모든 메세지(단, mark 메세지 종류는 제외)

 메세지 난이도(Level)
메세지 레벨        설  명
0 emerg (panic)   패닉상태, 모든 사용자에게 전달되어야 할 위험한 상황의 메세지
1 alert           즉각적인 조치를 위해야 상황의 메세지
2 crit            시스템에 문제가 생기는 단계의 메세지
3 error (err)     에러가 발생하는 경우의 메세지
4 warning (warn)  주의를 요하는 경고 메세지
5 notice          특별한 주의를 요하는 에러는 아닌 메세지
6 info            통계, 기본정보 메세지
7 debug           프로그램을 디버깅할 때 생성되는 메세지

실제 로그를 수집 하기 위한 정책에 대한 파일
메시지 기록 위치
# cat /etc/rsyslog.conf

Facility : 메세지의 종류
Level : 메세지의 난이도(위험 수준)
Action : 메세지 기록 위치


/etc/rsyslog.conf의 구성
authpriv.* /var/log/secure
Facility.Level      Action

메세지 기록 위치      설  명
/var/log/messages     기록을 남길 특정한 로그 파일 선택(예: /var/log/file.log)
만약에 없는 파일에 기록을 하는 경우 파일이 없어 에러가 날 수 있음. 미리 touch로 빈 파일을 생성
/dev/console          기록을 남길 콘솔에 로그 기록 남김(예: /dev/console)
user01,root, *        특정한 사용자나 모든 사용자 선택(예: user01, *)
@hostA, @172.16.8.254 다른 호스트 선택(예: @172.16.8.254)-> 보통 로그 서버 선택

예시파일
# cat /etc/syslog.conf
# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*                                                 /dev/console
커널에 관련한 모든 메세지는 콘솔창에 출력한다.

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
*.info;mail.none;news.none;authpriv.none;cron.none      /var/log/messages
메일(mail),뉴스(news),개인인증(authpriv),크론(cron) 메세지를 제외한 대부분의 메세지를 /var/log/messages 파일에 기록한다.

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure
개인적인 인증에 관련한 부분은 /var/log/secure 파일에 기록한다.(su, sshd)

# Log all the mail messages in one place.
mail.*                                                  -/var/log/maillog
메일에 관련한 모든 메세지는 /var/log/maillog 파일에 기록한다.
 -/var/log/maillog에서 -의 기능
기록 후 파일 동기화를 생략하기 위해 -를 접두사로 붙여 지정 가능
시스템이 쓰기를 시도 할 때 충돌 할 가능성이 있다. 성능에 따라서 사용 할 때 가 있음.

# Log cron stuff
cron.*                                                  /var/log/cron
크론(cron) 메세지 모두를 /var/log/cron 파일에 기록한다.

# Everybody gets emergency messages
*.emerg                                                 *
모든 경우 위험한 메세지(패닉 상태)는 모든 사용자에게 뿌린다.

# Save news errors of level crit and higher in a special file.
uucp,news.crit                                          /var/log/spooler
uucp,news에 대한 critical 이상 메세지는 /var/log/spooler 파일에 기록한다.

# Save boot messages also to boot.log
local7.*                                                /var/log/boot.log
미리 예약된 local7 종류에 대한 모든 메세지(부팅시의 메세지)를 /var/log/boot.log 파일에 기록한다.

#
# INN
#
news.=crit                                        /var/log/news/news.crit
news.=err                                         /var/log/news/news.err
news.notice                                       /var/log/news/news.notice

각 로그파일은 var/log 디렉토리에 존재한다.

로그파일                      설   명
(T) /var/log/messages      메일(mail), 뉴스(news), 인증(authpriv), 크론(cron) 메세지를 제외한 시스템의 전반적인 메세지를 기록하는 로그파일이다. 리눅스에서는 가장 많은 메세지를 담고 있는 파일이다. 
(TUI) # tail -f /var/log/messages 
(T) /var/log/secure        개인인증을 기록하는 로그파일이다.(EX: su, telnet, ssh)
(T) /var/log/dmesg         시스템이 부팅할때 메세지를 기록하는 로그 파일이다. dmesg 명령어가 이 파일을 참조하여 정보를 출력한다. # dmesg 
(D) /var/log/lastlog       사용자의 가장 마지막에 로그인한 시간을 기록하는 로그 파일이다. 바이너리 파일이므로 안의 내용을 cat 명령어를 통해 확인할 수 없다. lastlog 명령어가 이 파일을 참조하여 정보를 출력한다. # lastlog 
(T) /var/log/cron          crontab, at 명령어를 통해 실행했던 작업을 기록하는 로그 파일이다.
- crond -> crontab CMD
- atd   -> at CMD
(T) /var/log/maillog       postfix 메일 관련 작업을 기록하는 로그 파일이다.
(T) /var/log/xferlog       FTP 서버에서 업로드/다운로드을 기록하는 로그 파일이다.
(D) /var/log/wtmp          사용자의 로그인/로그아웃 시간을 기록하는 로그파일이다. 데이터 파일이므로 안의 내용을 cat 명령어를 통해 확인할 수 없다. last 명령어가 이 파일을 참조하여 정보를 출력한다. # last   (# last oracle)
(D) /var/run/utmp          현재 로그인한 사용자 정보를 기록하는 로그 파일이다. 데이터 파일이므로 안의 내용을 cat 명령어를 통해 확인 할 수 없다. who 명령어가 이 파일을 참조하여 정보를 출력한다. # who

logrotate
로그파일은 시간이 지남에따라 계속 계속 커진다.
1~2M 일때는 사실 상관 없음. 하지만 수많은 로그 데이터가 쌓이게 되면 파일을 오픈 하는 것도 힘들다.

32bit system : 코드 파일 ? 2.4G
open: 4시간 
하나의 파일이 너무 커지는 것을 방지하기 위해 logrotate를 사용한다.
logrotate를 통해 순환 파일로 제공
이전 방식: /var/log/messages.0 .1 .2 .3 
 /var/log/messages


현재 방식: var/log/messages-20220320

로그 데이터
Mar 20 20:11:48 localhost sshd[1433]: Failed password for student from 172.25.0.10 port 59344 ssh2

Mar 20 20:11:48 : 시간 timestamp
localhost  host 
sshd[1433]: id 사용자나 데몬이름 + PID
Failed password for student from 172.25.0.10 port 59344 ssh2 : 해당 로그의 상세한 내용
lastb

보통은logrotate를 통해 이동한 로그 파일들은 삭제 되기전에 tar 명령어를 통해 특정 디렉토리로 이동, 일정시간 저장 한 뒤에 ISO 이미지로 생성
cp 복사 > 시간 현재 시간 업데이트
tar -> 시간+ 권+ 소 + + 기존 파일 그대로 가지고 이동
컨테이너로 가면서 tar 명령어가 더 많이 사용

로그 이벤트 모니터링 방법
# tail -f /path/to/file : 일반 파일로 저장된 내용을 확인 하기 위해 사용
[root@servera log]# journalctl -f   < systemd-journal에서 나오는 데이터를 바로 확인

[104]
저널 보존

저널의 경우에는 부팅시 - 종료시까지 사용하고 기본 값은 삭제
/etc/systemd/ journald.conf 옵션을 조정하여 영구 보관 할 수 있도록 만들어야 함
#Storage=auto
auto :  /var/log/journal 디렉토리가 존재 한다면 systemd가 영구 보관용 데이터를 사용하고 없다면 /run/log 에서 처리
persistent : /var/log/journal 생성 부팅-종료시까지의 모든 데이터를 보관

필요하다면 저널 영구 저장 장치에 대한 작업을 실시한다.
ansible을 사용하다보니까 초기 구축시에 해당 작업을 완료.

NTP : network time protocol
많은 네트워크 프로그램들은 시간 동기화가 필요하게 된다. 네트워크 상에서 서로 연동하는 시스템들 간에 시간이 일치 하지 않게 된다면 다수의 시스템 장애처리, 성능카운트, 분석, 로깅등 수많은 문제점을 갖게된다.

시간 서버의 발전
이전에는 rdate 사용
현재는 ntp

[root@servera ~]# timedatectl
               Local time: Tue 2024-07-23 03:42:49 EDT   현재 시스템 시간
           Universal time: Tue 2024-07-23 07:42:49 UTC UTC의 시간 
                 RTC time: Tue 2024-07-23 07:42:49 하드웨어 시간
                Time zone: America/New_York (EDT, -0400) 현재 서버의 타임존 
System clock synchronized: yes  시간 동기화가 되어 있는지 확인
              NTP service: active  NTP 서비스가 실행중인지 
          RTC in local TZ: no

# date 월일시분
[root@servera ~]# date 06121300 
Wed Jun 12 01:00:00 PM EDT 2024

[root@servera ~]# timedatectl set-time 13:00:00
Failed to set time: Automatic time synchronization is enabled

[root@servera ~]# timedatectl set-time 13:00:00
Failed to set time: Automatic time synchronization is enabled
[root@servera ~]# timedatectl set-ntp 
false  true   
[root@servera ~]# timedatectl set-ntp false 
[root@servera ~]# timedatectl set-time 13:00:00

[root@servera ~]# timedatectl set-time '2012-10-30 13:00:00'
[root@servera ~]# timedatectl 
               Local time: Tue 2012-10-30 13:00:04 EDT
           Universal time: Tue 2012-10-30 17:00:04 UTC
                 RTC time: Tue 2012-10-30 17:00:04
                Time zone: America/New_York (EDT, -0400)
System clock synchronized: no
              NTP service: inactive
          RTC in local TZ: no

위의 내용은 timedatectl 명령을 이용하여 수동으로 시간을 변경
보통은 이렇게 하지 않음 NTP 서버가 동작하고 해당 서버를 바라보게 하기 때문에 이렇게 사용하지는 않는다.
[root@servera ~]# dnf -y remove chrony
chrony 삭제 후 진행

[root@servera ~]# ls -l $(which yum)
lrwxrwxrwx. 1 root root 5 Mar 21  2022 /usr/bin/yum -> dnf-3
[root@servera ~]# ls -l $(which dnf)
lrwxrwxrwx. 1 root root 5 Mar 21  2022 /usr/bin/dnf -> dnf-3

[root@servera ~]# dnf list
[root@servera ~]# dnf repolist
[root@servera ~]# dnf clean all

[root@servera ~]# dnf install telnetRed Hat Enterprise Linux 9.0 BaseOS (dvd)   779 kB/s | 2.7 kB     00:00    
Red Hat Enterprise Linux 9.0 AppStream (dvd 1.1 MB/s | 2.8 kB     00:00    
Dependencies resolved.
============================================================================
 Package Arch    Version          Repository                           Size
============================================================================
Installing:
 telnet  x86_64  1:0.17-85.el9    rhel-9.0-for-x86_64-appstream-rpms   66 k

Transaction Summary
============================================================================
Install  1 Package

Total download size: 66 k
Installed size: 121 k
Is this ok [y/N]: y
Downloading Packages:
telnet-0.17-85.el9.x86_64.rpm               398 kB/s |  66 kB     00:00    
----------------------------------------------------------------------------
Total                                       394 kB/s |  66 kB     00:00     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                    1/1 
  Installing       : telnet-1:0.17-85.el9.x86_64                        1/1 
  Running scriptlet: telnet-1:0.17-85.el9.x86_64                        1/1 
  Verifying        : telnet-1:0.17-85.el9.x86_64                        1/1 

Installed:
  telnet-1:0.17-85.el9.x86_64                                               

Complete!
[root@servera ~]# 
[root@servera ~]# dnf -y install ftp 
Red Hat Enterprise Linux 9.0 BaseOS (dvd)   628 kB/s | 2.7 kB     00:00    
Red Hat Enterprise Linux 9.0 AppStream (dvd 1.3 MB/s | 2.8 kB     00:00    
Dependencies resolved.
============================================================================
 Package
       Arch     Version          Repository                            Size
============================================================================
Installing:
 ftp   x86_64   0.17-89.el9      rhel-9.0-for-x86_64-appstream-rpms    64 k

Transaction Summary
============================================================================
Install  1 Package

Total download size: 64 k
Installed size: 112 k
Downloading Packages:
ftp-0.17-89.el9.x86_64.rpm                  1.1 MB/s |  64 kB     00:00    
----------------------------------------------------------------------------
Total                                       1.1 MB/s |  64 kB     00:00     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                    1/1 
  Installing       : ftp-0.17-89.el9.x86_64                             1/1 
  Running scriptlet: ftp-0.17-89.el9.x86_64                             1/1 
  Verifying        : ftp-0.17-89.el9.x86_64                             1/1 

Installed:
  ftp-0.17-89.el9.x86_64                                                    

Complete!
[root@servera ~]# 

install  : 설치
remove  : 삭제

ntp를 구성하여 클라이언트로서 동작 시키기
1 패키지 설치
# dnf -y install chrony
[root@servera ~]# rpm -ql chrony
chrony 패키지에서 추출된 파일 목록 확인
[root@servera ~]# rpm -qlc chrony
설정 파일만 모아보기
[root@servera ~]# rpm -qld chrony
문서파일만 모아보기
/etc/chrony.conf : chrony에서의 설정 파일
해당 파일에서 클라이언트 구성은 1번 섹션이다.
server / pool
server : 단독 서버 
pool : 다수의 서버로 구성되어 있다.
server 2.rhel.pool.ntp.org iburst
server : 서버를 지정
2.rhel.pool.ntp.org : 서버로 지정할 호스트/ IP 
iburst : 타임 서버들은 초기 서비스에 걸리는 동기화 시간이 존재한다. 서비스를 시작하고 외부, 내부망에서 네트워크를 확인한 뒤 패킷을 보내 동기화를 시작
패킷을 전송하고 다음 패킷까지 걸리는 시간은 16초가 걸린다. 이 시간을 줄이기 위해서 한번에 8개를 동시에 전송하라는 옵션이다.
[root@servera ~]# vi  /etc/chrony.conf
#pool 2.rhel.pool.ntp.org iburst  <  기존 라인 주석 처리
server classroom.example.com iburst 
:wq

여기부터 따라하면 됩니다.
[root@servera ~]# timedatectl set-ntp false 
[root@servera ~]# timedatectl set-time '2012-10-30 13:00:00'
[root@servera ~]# systemctl daemon-reload   < systemd에 변경된 파일이 있으면 업데이트
[root@servera ~]# systemctl enable --now chronyd 
Created symlink /etc/systemd/system/multi-user.target.wants/chronyd.service → /usr/lib/systemd/system/chronyd.service.
사용한 명령:  systemctl enable --now chronyd 
1 systemctl start chronyd 
2 systemctl enable chronyd 
[root@servera ~]# systemctl is-active chronyd
active
[root@servera ~]# systemctl is-enabled chronyd
enabled

[root@servera ~]# systemctl status chronyd
● chronyd.service - NTP client/server
     Loaded: loaded (/usr/lib/systemd/system/chronyd.service; enabled; vendor preset: enabled)
     Active: active (running) since Tue 2012-10-30 13:00:38 EDT; 11 years 8 months ago
       Docs: man:chronyd(8)
             man:chrony.conf(5)
    Process: 27544 ExecStart=/usr/sbin/chronyd $OPTIONS (code=exited, status=0/SUCCESS)
   Main PID: 27546 (chronyd)
      Tasks: 1 (limit: 10799)
     Memory: 804.0K
        CPU: 21ms
     CGroup: /system.slice/chronyd.service
             └─27546 /usr/sbin/chronyd -F 2

[root@servera ~]# timedatectl 
               Local time: Tue 2024-07-23 04:24:32 EDT
           Universal time: Tue 2024-07-23 08:24:32 UTC
                 RTC time: Tue 2024-07-23 08:24:32
                Time zone: America/New_York (EDT, -0400)
System clock synchronized: yes   <<< 싱크가 완료
              NTP service: active    <<< 활성화
          RTC in local TZ: no

다른 터미널을 열어서 root 권한으로 아래의 명령을 실행한다.
[root@servera ~]# while true; do date 06191300 ; sleep 1; done

[root@servera ~]# chronyc sources
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^? 172.25.254.254                0   6   377     -     +0ns[   +0ns] +/-    0ns

[root@servera ~]# chronyc sources -v

  .-- Source mode  '^' = server, '=' = peer, '#' = local clock.
 / .- Source state '*' = current best, '+' = combined, '-' = not combined,
| /             'x' = may be in error, '~' = too variable, '?' = unusable.
||                                                 .- xxxx [ yyyy ] +/- zzzz
||      Reachability register (octal) -.           |  xxxx = adjusted offset,
||      Log2(Polling interval) --.      |          |  yyyy = measured offset,
||                                \     |          |  zzzz = estimated error.
||                                 |    |           \
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^? 172.25.254.254                0   6   377     -     +0ns[   +0ns] +/-    0ns


[root@servera ~]# watch -n 1 'chronyc sources -v'
시간 동기화를 모니터링
[root@servera ~]# timedatectl set-ntp false ; date 06191300 ; timedatectl set-ntp true 



  .-- Source mode  '^' = server, '=' = peer, '#' = local clock.
 / .- Source state '*' = current best, '+' = combined, '-' = not combined,
| /             'x' = may be in error, '~' = too variable, '?' = unusable.
||                                                 .- xxxx [ yyyy ] +/- zzzz
||      Reachability register (octal) -.           |  xxxx = adjusted offset,
||      Log2(Polling interval) --.      |          |  yyyy = measured offset,
||                                \     |          |  zzzz = estimated error.
||                                 |    |           \
MS Name/IP address         Stratum Poll Reach LastRx Last sample
===============================================================================
^* 172.25.254.254                2   6    17    32  -1154ns[-3900ns] +/- 3832us
동기화가 완료 되면 Reach 값이 377로 유지된다.

다시한번 이렇게 구성
[root@servera ~]# timedatectl set-ntp false ; date 06191300

[root@servera ~]# timedatectl set-ntp true  
[root@servera ~]# chronyc -a makestep 
200 OK
200 OK chronyc -a makestep 이 명령어는 NTP 서버와 최대한 근접하게 시간을 수정하여 동기화 되는 시간을 줄여줄수 있다.

타임존을 변경해야 하는 경우에는 아래와 같이 사용한다.
[root@servera ~]# timedatectl set-timezone Asia/Seoul 
[root@servera ~]# timedatectl
               Local time: Tue 2024-07-23 17:35:30 KST
           Universal time: Tue 2024-07-23 08:35:30 UTC
                 RTC time: Tue 2024-07-23 08:35:30
                Time zone: Asia/Seoul (KST, +0900)
System clock synchronized: yes
              NTP service: active
          RTC in local TZ: no


MS Name/IP address         Stratum Poll Reach LastRx Last sample
===============================================================================
^* 172.25.254.254                2   6   377    49  +5620ns[  +17us] +/- 4601us

Reach 이 377이면 동기화가 완료 되었다 라고 보면 된다.

시험에서는 설정 파일을 구성하고 ntp 서비스에서 대해 enabled만 구성되면 끝
패키지 설치 / 설정 파일 변경 / enabled 확인

연습문제는 내일 오전에 하고
 
storage 부터 7장 나가도록 하겠습니다.





















































